// MIT License
//
// Copyright (c) 2018 Zig Programming Language
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
//
// ------------------------------------------------------------------------------
//
// the following is a grammar for the zig programming language,
// modified for use in the Zapp parser generator.
// the original grammar can be found at: https://github.com/ziglang/zig-spec
// and corresponds to commit: 75129c7a34010ead828055c26a6d41d1516faa97.
//

%% NAME Zig

Root = SKIP CONTAINER_DOC_COMMENT? ContainerMembers EOF ;

// *** Top level ***
ContainerMembers = ContainerDeclarations (ContainerField COMMA ^)* ContainerMembersSuffix ;

ContainerMembersSuffix
    = ContainerField
    | ContainerDeclarations
    ;

ContainerDeclarations = (&ContainerDeclarationPrefix ^ ContainerDeclaration)* ;

ContainerDeclarationPrefix 
    = KEYWORD_TEST
    | KEYWORD_COMPTIME LBRACE
    | (&'///' ^ DOC_COMMENT)? KEYWORD_PUB? DeclPrefix
    ;

DeclPrefix 
    = FnSpecifier KEYWORD_FN
    | KEYWORD_USINGNAMESPACE
    | VarSpecifier KEYWORD_THREADLOCAL? VarDeclKeyword
    ;

ContainerDeclaration 
    = &KEYWORD_TEST ^ TestDecl 
    | &KEYWORD_COMPTIME ^ ComptimeDecl 
    | DOC_COMMENT? KEYWORD_PUB? Decl
    ;

TestDecl = KEYWORD_TEST TestIdentifier Block ;
TestIdentifier 
    = STRINGLITERALSINGLE 
    | IDENTIFIER
    | @
    ;

ComptimeDecl = KEYWORD_COMPTIME Block ;

Decl
    = FnSpecifier FnProto SEMICOLON 
    | FnSpecifier FnProto ^ Block
    | KEYWORD_USINGNAMESPACE ^ Expr SEMICOLON
    | VarSpecifier KEYWORD_THREADLOCAL? GlobalVarDecl
    ;

FnSpecifier 
    = KEYWORD_INLINE
    | KEYWORD_NOINLINE
    | VarSpecifier
    ;

VarSpecifier 
    = KEYWORD_EXPORT 
    | KEYWORD_EXTERN STRINGLITERALSINGLE?
    | @
    ;

FnProto = KEYWORD_FN IDENTIFIER? LPAREN ParamDeclList RPAREN ByteAlign? AddrSpace? LinkSection? CallConv? EXCLAMATIONMARK? TypeExpr ;

VarDeclProto = VarDeclKeyword IDENTIFIER (COLON ^ TypeExpr)? ByteAlign? AddrSpace? LinkSection? ;

VarDeclKeyword 
    = KEYWORD_CONST 
    | KEYWORD_VAR
    ;

GlobalVarDecl = VarDeclProto (EQUAL ^ Expr)? SEMICOLON ;

ContainerField = DOC_COMMENT? KEYWORD_COMPTIME? !KEYWORD_FN (IDENTIFIER COLON)? TypeExpr ByteAlign? (EQUAL ^ Expr)? ;

// *** Block Level ***
Statement
    = KEYWORD_COMPTIME ^ ComptimeStatement
    | KEYWORD_NOSUSPEND ^ BlockExprStatement
    | KEYWORD_SUSPEND ^ BlockExprStatement
    | KEYWORD_DEFER ^ BlockExprStatement
    | KEYWORD_ERRDEFER ^ Payload? BlockExprStatement
    | &KEYWORD_IF ^ IfStatement
    | &KEYWORD_SWITCH ^ SwitchExpr
    | &LabeledStatementPrefix ^ LabeledStatement
    | VarDeclExprStatement
    ;

ComptimeStatement
    = &(BlockLabel? LBRACE) ^ BlockExpr
    | VarDeclExprStatement
    ;

IfStatement
    = IfPrefix &(BlockLabel? LBRACE) ^ BlockExpr ( KEYWORD_ELSE ^ Payload? Statement )?
    | IfPrefix AssignExpr IfStatementAssignSuffix
    ;

IfStatementAssignSuffix
    = KEYWORD_ELSE ^ Payload? Statement 
    | SEMICOLON
    ;

LabeledStatementPrefix 
    = BlockLabel? LBRACE
    | BlockLabel? KEYWORD_INLINE? KEYWORD_FOR
    | BlockLabel? KEYWORD_INLINE? KEYWORD_WHILE
    ;

LabeledStatement 
    = BlockLabel? &LBRACE ^ Block 
    | BlockLabel? LoopStatement 
    ;

LoopStatement 
    = KEYWORD_INLINE? &KEYWORD_FOR ^ ForStatement 
    | KEYWORD_INLINE? WhileStatement
    ;

ForStatement
    = ForPrefix &(BlockLabel? LBRACE) ^ BlockExpr ( KEYWORD_ELSE ^ Statement )? 
    | ForPrefix AssignExpr ForAssignSuffix
    ;

ForAssignSuffix
    = KEYWORD_ELSE ^ Statement
    | SEMICOLON
    ;

WhileStatement
    = WhilePrefix &(BlockLabel? LBRACE) ^ BlockExpr ( KEYWORD_ELSE ^ Payload? Statement )?
    | WhilePrefix AssignExpr WhileStatementAssignSuffix
    ;

WhileStatementAssignSuffix
    = KEYWORD_ELSE ^ Payload? Statement
    | SEMICOLON
    ;


BlockExprStatement
    = &(BlockLabel? LBRACE) ^ BlockExpr
    | AssignExpr SEMICOLON
    ;

BlockExpr = BlockLabel? Block ;

// An expression, assignment, or any destructure, as a statement.
VarDeclExprStatement
    = &VarDeclKeyword ^ VarDeclProto (COMMA ^ VarDeclOrExpr)* EQUAL Expr SEMICOLON
    | Expr VarDeclExprStatementExprSuffix
    ;

VarDeclExprStatementExprSuffix
    = AssignOp ^ Expr SEMICOLON
    | (COMMA ^ VarDeclOrExpr)+ EQUAL Expr SEMICOLON
    | SEMICOLON
    ;

VarDeclOrExpr 
    = VarDeclProto 
    | Expr
    ;

// *** Expression Level ***

// An assignment or a destructure whose LHS are all lvalue expressions.
AssignExprSuffix 
    =  AssignOp ^ Expr 
    | (COMMA ^ Expr)+ EQUAL Expr
    | @
    ;

AssignExpr = Expr AssignExprSuffix;

SingleAssignExpr = Expr (AssignOp Expr)? ;

Expr = BoolOrExpr ;

BoolOrExpr = BoolAndExpr (KEYWORD_OR ^ BoolAndExpr)* ;

BoolAndExpr = CompareExpr (KEYWORD_AND ^ CompareExpr)* ;

CompareExpr = BitwiseExpr (CompareOp ^ BitwiseExpr)? ;

BitwiseExpr = BitShiftExpr (BitwiseOp ^ BitShiftExpr)* ;

BitShiftExpr = AdditionExpr (BitShiftOp ^ AdditionExpr)* ;

AdditionExpr = MultiplyExpr (AdditionOp ^ MultiplyExpr)* ; 

MultiplyExpr = PrefixExpr (MultiplyOp ^ PrefixExpr)* ;

PrefixExpr = (PrefixOp ^)* PrimaryExpr ;

PrimaryExpr
    = &KEYWORD_ASM ^ AsmExpr
    | &KEYWORD_IF ^ IfExpr
    | KEYWORD_BREAK ^ BreakLabel? Expr?
    | KEYWORD_COMPTIME ^ Expr
    | KEYWORD_NOSUSPEND ^ Expr
    | KEYWORD_CONTINUE ^ BreakLabel?
    | KEYWORD_RESUME ^ Expr
    | KEYWORD_RETURN ^ Expr?
    | BlockLabel? &(KEYWORD_INLINE? LoopPrefix) ^ LoopExpr
    | &LBRACE ^ Block
    | CurlySuffixExpr
    ;

IfExpr = IfPrefix Expr (KEYWORD_ELSE ^ Payload? Expr)? ;

Block = LBRACE (!RBRACE ^ Statement)* RBRACE ;

LoopExpr 
    = KEYWORD_INLINE? &KEYWORD_FOR ^ ForExpr
    | KEYWORD_INLINE? WhileExpr
    ;

LoopPrefix
    = KEYWORD_FOR
    | KEYWORD_WHILE
    ;

ForExpr = ForPrefix Expr (KEYWORD_ELSE ^ Expr)? ;

WhileExpr = WhilePrefix Expr (KEYWORD_ELSE ^ Payload? Expr)? ;

CurlySuffixExpr = TypeExpr (&LBRACE ^ InitList)? ;

InitList
    = LBRACE &(DOT IDENTIFIER EQUAL) ^ FieldInit (COMMA !RBRACE ^ FieldInit)* COMMA? RBRACE
    | LBRACE RBRACE
    | LBRACE Expr (COMMA !RBRACE ^ Expr)* COMMA? RBRACE
    ;

TypeExpr = (PrefixTypeOp ^)* ErrorUnionExpr ;

ErrorUnionExpr = SuffixExpr (EXCLAMATIONMARK ^ TypeExpr)? ;

SuffixExpr
    = KEYWORD_ASYNC ^ PrimaryTypeExpr (SuffixOp ^)* FnCallArguments 
    | PrimaryTypeExpr (!EXCLAMATIONMARK SuffixOpOrCallArgs)*
    ;

SuffixOpOrCallArgs 
    = SuffixOp
    | FnCallArguments
    ;

PrimaryTypeExpr
    = BUILTINIDENTIFIER ^ FnCallArguments
    | CHAR_LITERAL
    | &ContainerDeclPrefix ^ ContainerDecl
    | DOT IDENTIFIER
    | DOT ^ InitList
    | &(KEYWORD_ERROR LBRACE) ^ ErrorSetDecl
    | FLOAT
    | &KEYWORD_FN ^ FnProto
    | &LPAREN ^ GroupedExpr
    | LabeledTypeExpr
    | IDENTIFIER
    | &KEYWORD_IF ^ IfTypeExpr
    | INTEGER
    | KEYWORD_COMPTIME ^ TypeExpr
    | KEYWORD_ERROR DOT ^ IDENTIFIER
    | KEYWORD_ANYFRAME
    | KEYWORD_UNREACHABLE
    | STRINGLITERAL
    | SwitchExpr
    ;

ContainerDecl 
    = KEYWORD_EXTERN ^ ContainerDeclAuto
    | KEYWORD_PACKED ^ ContainerDeclAuto
    | ContainerDeclAuto 
    ;

ContainerDeclPrefix
    = KEYWORD_EXTERN ^ ContainerDeclType
    | KEYWORD_PACKED ^ ContainerDeclType
    | ContainerDeclType
    ;

ErrorSetDecl = KEYWORD_ERROR LBRACE IdentifierList RBRACE ;

GroupedExpr = LPAREN Expr RPAREN ;

IfTypeExpr = IfPrefix TypeExpr (KEYWORD_ELSE ^ Payload? TypeExpr)? ;

LabeledTypeExpr
    = BlockLabel &LBRACE ^ Block
    | BlockLabel? LoopTypeExpr
    ;

LoopTypeExpr 
    = KEYWORD_INLINE? &KEYWORD_FOR ^ ForTypeExpr 
    | KEYWORD_INLINE? WhileTypeExpr
    ;

ForTypeExpr = ForPrefix TypeExpr (KEYWORD_ELSE ^ TypeExpr)? ;

WhileTypeExpr = WhilePrefix TypeExpr (KEYWORD_ELSE ^ Payload? TypeExpr)? ;

SwitchExpr = KEYWORD_SWITCH LPAREN Expr RPAREN LBRACE SwitchProngList RBRACE ;

// *** Assembly ***
AsmExpr = KEYWORD_ASM KEYWORD_VOLATILE? LPAREN Expr AsmOutput? RPAREN ;

AsmOutput = COLON AsmOutputList AsmInput? ;

AsmOutputItem = LBRACKET IDENTIFIER RBRACKET STRINGLITERAL LPAREN AsmResultType RPAREN ;

AsmResultType 
    = MINUSRARROW ^ TypeExpr 
    | IDENTIFIER 
    ;

AsmInput = COLON AsmInputList AsmClobbers? ;

AsmInputItem = LBRACKET IDENTIFIER RBRACKET STRINGLITERAL LPAREN Expr RPAREN ;

AsmClobbers = COLON StringList ;

// *** Helper grammar ***
BreakLabel = COLON IDENTIFIER ;

BlockLabel = IDENTIFIER COLON ;

FieldInit = DOT IDENTIFIER EQUAL Expr ;

WhileContinueExpr = COLON LPAREN AssignExpr RPAREN ;

LinkSection = KEYWORD_LINKSECTION LPAREN Expr RPAREN ;

AddrSpace = KEYWORD_ADDRSPACE LPAREN Expr RPAREN ;

// Fn specific
CallConv = KEYWORD_CALLCONV LPAREN Expr RPAREN ;

ParamDecl
    = DOC_COMMENT? KEYWORD_NOALIAS ^ (IDENTIFIER COLON)? ParamType
    | DOC_COMMENT? KEYWORD_COMPTIME ^ (IDENTIFIER COLON)? ParamType
    | DOC_COMMENT? (IDENTIFIER COLON)? ParamType
    | DOT3
    ;

ParamType
    = KEYWORD_ANYTYPE
    | TypeExpr
    ;

// Control flow prefixes
IfPrefix = KEYWORD_IF LPAREN Expr RPAREN PtrPayload? ;

WhilePrefix = KEYWORD_WHILE LPAREN Expr RPAREN PtrPayload? WhileContinueExpr? ;

ForPrefix = KEYWORD_FOR LPAREN ForArgumentsList RPAREN PtrListPayload ;

// Payloads
Payload = PIPE IDENTIFIER PIPE ;

PtrPayload = PIPE ASTERISK? IDENTIFIER PIPE ;

PtrIndexPayload = PIPE ASTERISK? IDENTIFIER (COMMA ^ IDENTIFIER)? PIPE ;

PtrListPayload = PIPE ASTERISK? IDENTIFIER (COMMA ^ ASTERISK? IDENTIFIER )* COMMA? PIPE ;

// Switch specific
SwitchProng = KEYWORD_INLINE? SwitchCase EQUALRARROW PtrIndexPayload? SingleAssignExpr ;

SwitchCase
    = SwitchItem ^ (COMMA SwitchItem ^)* COMMA?
    | KEYWORD_ELSE
    ;

SwitchItem = Expr (DOT3 ^ Expr)? ;

// For specific
ForArgumentsList = ForItem (COMMA ForItem ^)* COMMA? ;

ForItem = Expr (DOT2 ^ Expr?)? ;

// Operators
AssignOp
    = ASTERISKEQUAL
    | ASTERISKPIPEEQUAL
    | SLASHEQUAL
    | PERCENTEQUAL
    | PLUSEQUAL
    | PLUSPIPEEQUAL
    | MINUSEQUAL
    | MINUSPIPEEQUAL
    | LARROW2EQUAL
    | LARROW2PIPEEQUAL
    | RARROW2EQUAL
    | AMPERSANDEQUAL
    | CARETEQUAL
    | PIPEEQUAL
    | ASTERISKPERCENTEQUAL
    | PLUSPERCENTEQUAL
    | MINUSPERCENTEQUAL
    | EQUAL
    ;

CompareOp
    = EQUALEQUAL
    | EXCLAMATIONMARKEQUAL
    | LARROW
    | RARROW
    | LARROWEQUAL
    | RARROWEQUAL
    ;

BitwiseOp
    = AMPERSAND
    | CARET
    | PIPE
    | KEYWORD_ORELSE
    | KEYWORD_CATCH Payload?
    ;

BitShiftOp
    = LARROW2
    | RARROW2
    | LARROW2PIPE
    ;

AdditionOp
    = PLUS
    | MINUS
    | PLUS2
    | PLUSPERCENT
    | MINUSPERCENT
    | PLUSPIPE
    | MINUSPIPE
    ;

MultiplyOp
    = PIPE2
    | ASTERISK
    | SLASH
    | PERCENT
    | ASTERISK2
    | ASTERISKPERCENT
    | ASTERISKPIPE
    ;

PrefixOp
    = EXCLAMATIONMARK
    | MINUS
    | TILDE
    | MINUSPERCENT
    | AMPERSAND
    | KEYWORD_TRY
    | KEYWORD_AWAIT
    ;

PrefixTypeOp
    = QUESTIONMARK
    | KEYWORD_ANYFRAME ^ MINUSRARROW
    | SliceTypeStart ^ (SliceTypeSpecifier ^)*
    | PtrTypeStart ^ (PtrTypeSpecifier ^)*
    | ArrayTypeStart
    ;

PtrTypeSpecifier
    // Would like to find an example of that one
    = KEYWORD_ALIGN LPAREN Expr COLON ^ Expr COLON Expr RPAREN
    | SliceTypeSpecifier
    ;

SliceTypeSpecifier 
    = ByteAlign 
    | AddrSpace 
    | KEYWORD_CONST 
    | KEYWORD_VOLATILE 
    | KEYWORD_ALLOWZERO 
    ;

SuffixOp
    = LBRACKET ^ Expr (DOT2 ^ (Expr? (COLON ^ Expr)?)?)? RBRACKET
    | DOT ^ IDENTIFIER
    | DOTASTERISK
    | DOTQUESTIONMARK
    ;

FnCallArguments = LPAREN ExprList RPAREN ;

// Ptr specific
SliceTypeStart = LBRACKET (COLON ^ Expr)? RBRACKET ;

PtrTypeStart
    = ASTERISK
    | ASTERISK2
    | LBRACKET ASTERISK LETTERC ^ RBRACKET
    | LBRACKET ASTERISK COLON ^ Expr RBRACKET
    | LBRACKET ASTERISK RBRACKET
    ;

ArrayTypeStart = LBRACKET Expr (COLON ^ Expr)? RBRACKET ;

// ContainerDecl specific
ContainerDeclAuto = ContainerDeclType LBRACE CONTAINER_DOC_COMMENT? ContainerMembers RBRACE ;

ContainerDeclType
    = KEYWORD_STRUCT ^ (LPAREN ^ Expr RPAREN)?
    | KEYWORD_OPAQUE
    | KEYWORD_ENUM ^ (LPAREN ^ Expr RPAREN)?
    | KEYWORD_UNION (LPAREN ^ UnionTypeArg RPAREN)?
    ;

UnionTypeArg 
    = KEYWORD_ENUM ^ (LPAREN ^ Expr RPAREN)? 
    | Expr 
    ;

// Alignment
ByteAlign = KEYWORD_ALIGN LPAREN Expr RPAREN ;

// Lists
IdentifierList = (DOC_COMMENT? IDENTIFIER COMMA ^)* (DOC_COMMENT? IDENTIFIER)? ;

SwitchProngList = (SwitchProng COMMA ^)* SwitchProng? ;

AsmOutputList = (AsmOutputItem COMMA ^)* AsmOutputItem? ;

AsmInputList = (AsmInputItem COMMA ^)* AsmInputItem? ;

StringList = (STRINGLITERAL COMMA ^)* STRINGLITERAL? ;

ParamDeclList = (ParamDecl COMMA ^)* ParamDecl? ;

ExprList = (Expr COMMA ^)* Expr? ;

// *** Tokens ***
EOF = !. ;
BIN = [01] ;
BIN_ = '_'? BIN ;
OCT = [0-7] ;
OCT_ = '_'? OCT ;
HEX = [0-9a-fA-F] ;
HEX_ = '_'? HEX ;
DEC = [0-9] ;
DEC_ = '_'? DEC ;

BIN_INT = BIN BIN_* !BIN_ ;
OCT_INT = OCT OCT_* !OCT_ ;
DEC_INT = DEC DEC_* !DEC_ ;
HEX_INT = HEX HEX_* !HEX_ ;

// From https://lemire.me/blog/2018/05/09/how-quickly-can-you-check-that-a-string-is-valid-unicode-utf-8/
MB_UTF8_LITERAL
    = '\xF4'      [\x80-\x8F] [\x80-\xBF] [\x80-\xBF]    
    | [\xF1-\xF3] [\x80-\xBF] [\x80-\xBF] [\x80-\xBF]     
    | '\xF0'      [\x90-\xBF] [\x80-\xBF] [\x80-\xBF]    
    | [\xEE-\xEF] [\x80-\xBF] [\x80-\xBF]
    | '\xED'      [\x80-\x9F] [\x80-\xBF]
    | [\xE1-\xEC] [\x80-\xBF] [\x80-\xBF]
    | '\xE0'      [\xA0-\xBF] [\x80-\xBF]
    | [\xC2-\xDF] [\x80-\xBF]
    ;

// No null allowed in the generator (maybe look at how the zig parser handles this)
ASCII_CHAR_NOT_NL_SLASH_SQUOTE 
    = [\x01-\x09\x0B-\x26\x28-\x5B\x5D-\x7F] 
    ;

CHAR_ESCAPE
    = "\\x" HEX HEX
    | "\\u{" HEX+ "}"
    | "\\" [nr\\t'"]
    ;

CHAR_CHAR
    = MB_UTF8_LITERAL
    | CHAR_ESCAPE
    | ASCII_CHAR_NOT_NL_SLASH_SQUOTE
    ;

STRING_CHAR
    = CHAR_ESCAPE
    | ![\\"\n] .
    ;

CONTAINER_DOC_COMMENT = ('//!' (!'\n' .)* [ \n]* SKIP)+ ;
DOC_COMMENT = ('///' (!'\n' .)* [ \n]* SKIP)+ ; 
LINE_COMMENT
    = '//' ![!/] (!'\n' .)* !(![\n] .) 
    | '////' (!'\n' .)* !(![\n] .)
    ;

LINE_STRING = ("\\\\" (![\n] .)* [ \n]*)+ ;
SKIP = WHITESPACE* !WHITESPACE_START ;

WHITESPACE_START 
    = [ \n]
    | '//' ![!/]
    | '////'
    ;

WHITESPACE
    = [ \n]
    | LINE_COMMENT
    ;

CHAR_LITERAL = "'" CHAR_CHAR "'" SKIP;

FLOAT
    = "0x" HEX_INT "."  HEX_INT ([pP] [-+]? DEC_INT)? SKIP
    |      DEC_INT "."  DEC_INT ([eE] [-+]? DEC_INT)? SKIP
    | "0x" HEX_INT [pP] [-+]? DEC_INT SKIP
    |      DEC_INT [eE] [-+]? DEC_INT SKIP
    ;

INTEGER
    = "0b" BIN_INT SKIP 
    | "0o" OCT_INT SKIP
    | "0x" HEX_INT SKIP
    |      DEC_INT SKIP
    ;

STRINGLITERALSINGLE = "\"" STRING_CHAR* "\"" SKIP;
STRINGLITERAL
    = STRINGLITERALSINGLE
    | (LINE_STRING                 SKIP)+ 
    ;

IDENTIFIER
    = !KEYWORD [A-Za-z_] [A-Za-z0-9_]* END_OF_WORD
    | "@" STRINGLITERALSINGLE
    ;

BUILTINIDENTIFIER = "@"[A-Za-z_][A-Za-z0-9_]* END_OF_WORD;

AMPERSAND            = '&'      ![=]      SKIP;
AMPERSANDEQUAL       = '&='               SKIP;
ASTERISK             = '*'      ![*%=|]   SKIP;
ASTERISK2            = '**'               SKIP;
ASTERISKEQUAL        = '*='               SKIP;
ASTERISKPERCENT      = '*%'     ![=]      SKIP;
ASTERISKPERCENTEQUAL = '*%='              SKIP;
ASTERISKPIPE         = '*|'     ![=]      SKIP;
ASTERISKPIPEEQUAL    = '*|='              SKIP;
CARET                = '^'      ![=]      SKIP;
CARETEQUAL           = '^='               SKIP;
COLON                = ':'                SKIP;
COMMA                = ','                SKIP;
DOT                  = '.'      ![*.?]    SKIP;
DOT2                 = '..'     ![.]      SKIP;
DOT3                 = '...'              SKIP;
DOTASTERISK          = '.*'               SKIP;
DOTQUESTIONMARK      = '.?'               SKIP;
EQUAL                = '='      ![>=]     SKIP;
EQUALEQUAL           = '=='               SKIP;
EQUALRARROW          = '=>'               SKIP;
EXCLAMATIONMARK      = '!'      ![=]      SKIP;
EXCLAMATIONMARKEQUAL = '!='               SKIP;
LARROW               = '<'      ![<=]     SKIP;
LARROW2              = '<<'     ![=|]     SKIP;
LARROW2EQUAL         = '<<='              SKIP;
LARROW2PIPE          = '<<|'    ![=]      SKIP;
LARROW2PIPEEQUAL     = '<<|='             SKIP;
LARROWEQUAL          = '<='               SKIP;
LBRACE               = '{'                SKIP;
LBRACKET             = '['                SKIP;
LPAREN               = '('                SKIP;
MINUS                = '-'      ![%=>|]   SKIP;
MINUSEQUAL           = '-='               SKIP;
MINUSPERCENT         = '-%'     ![=]      SKIP;
MINUSPERCENTEQUAL    = '-%='              SKIP;
MINUSPIPE            = '-|'     ![=]      SKIP;
MINUSPIPEEQUAL       = '-|='              SKIP;
MINUSRARROW          = '->'               SKIP;
PERCENT              = '%'      ![=]      SKIP;
PERCENTEQUAL         = '%='               SKIP;
PIPE                 = '|'      ![|=]     SKIP;
PIPE2                = '||'               SKIP;
PIPEEQUAL            = '|='               SKIP;
PLUS                 = '+'      ![%+=|]   SKIP;
PLUS2                = '++'               SKIP;
PLUSEQUAL            = '+='               SKIP;
PLUSPERCENT          = '+%'     ![=]      SKIP;
PLUSPERCENTEQUAL     = '+%='              SKIP;
PLUSPIPE             = '+|'     ![=]      SKIP;
PLUSPIPEEQUAL        = '+|='              SKIP;
LETTERC              = 'c'                SKIP;
QUESTIONMARK         = '?'                SKIP;
RARROW               = '>'      ![>=]     SKIP;
RARROW2              = '>>'     ![=]      SKIP;
RARROW2EQUAL         = '>>='              SKIP;
RARROWEQUAL          = '>='               SKIP;
RBRACE               = '}'                SKIP;
RBRACKET             = ']'                SKIP;
RPAREN               = ')'                SKIP;
SEMICOLON            = ';'                SKIP;
SLASH                = '/'      ![=]      SKIP;
SLASHEQUAL           = '/='               SKIP;
TILDE                = '~'                SKIP;

END_OF_WORD = ![a-zA-Z0-9_] SKIP;
KEYWORD_ADDRSPACE   = 'addrspace'   END_OF_WORD ;
KEYWORD_ALIGN       = 'align'       END_OF_WORD ;
KEYWORD_ALLOWZERO   = 'allowzero'   END_OF_WORD ;
KEYWORD_AND         = 'and'         END_OF_WORD ;
KEYWORD_ANYFRAME    = 'anyframe'    END_OF_WORD ;
KEYWORD_ANYTYPE     = 'anytype'     END_OF_WORD ;
KEYWORD_ASM         = 'asm'         END_OF_WORD ;
KEYWORD_ASYNC       = 'async'       END_OF_WORD ;
KEYWORD_AWAIT       = 'await'       END_OF_WORD ;
KEYWORD_BREAK       = 'break'       END_OF_WORD ;
KEYWORD_CALLCONV    = 'callconv'    END_OF_WORD ;
KEYWORD_CATCH       = 'catch'       END_OF_WORD ;
KEYWORD_COMPTIME    = 'comptime'    END_OF_WORD ; 
KEYWORD_CONST       = 'const'       END_OF_WORD ;
KEYWORD_CONTINUE    = 'continue'    END_OF_WORD ;
KEYWORD_DEFER       = 'defer'       END_OF_WORD ;
KEYWORD_ELSE        = 'else'        END_OF_WORD ;
KEYWORD_ENUM        = 'enum'        END_OF_WORD ;
KEYWORD_ERRDEFER    = 'errdefer'    END_OF_WORD ;
KEYWORD_ERROR       = 'error'       END_OF_WORD ;
KEYWORD_EXPORT      = 'export'      END_OF_WORD ;
KEYWORD_EXTERN      = 'extern'      END_OF_WORD ;
KEYWORD_FN          = 'fn'          END_OF_WORD ;
KEYWORD_FOR         = 'for'         END_OF_WORD ;
KEYWORD_IF          = 'if'          END_OF_WORD ;
KEYWORD_INLINE      = 'inline'      END_OF_WORD ;
KEYWORD_NOALIAS     = 'noalias'     END_OF_WORD ;
KEYWORD_NOSUSPEND   = 'nosuspend'   END_OF_WORD ;
KEYWORD_NOINLINE    = 'noinline'    END_OF_WORD ;
KEYWORD_OPAQUE      = 'opaque'      END_OF_WORD ;
KEYWORD_OR          = 'or'          END_OF_WORD ;
KEYWORD_ORELSE      = 'orelse'      END_OF_WORD ;
KEYWORD_PACKED      = 'packed'      END_OF_WORD ;
KEYWORD_PUB         = 'pub'         END_OF_WORD ;
KEYWORD_RESUME      = 'resume'      END_OF_WORD ;
KEYWORD_RETURN      = 'return'      END_OF_WORD ;
KEYWORD_LINKSECTION = 'linksection' END_OF_WORD ;
KEYWORD_STRUCT      = 'struct'      END_OF_WORD ;
KEYWORD_SUSPEND     = 'suspend'     END_OF_WORD ;
KEYWORD_SWITCH      = 'switch'      END_OF_WORD ;
KEYWORD_TEST        = 'test'        END_OF_WORD ;
KEYWORD_THREADLOCAL = 'threadlocal' END_OF_WORD ;
KEYWORD_TRY         = 'try'         END_OF_WORD ;
KEYWORD_UNION       = 'union'       END_OF_WORD ;
KEYWORD_UNREACHABLE = 'unreachable' END_OF_WORD ;
KEYWORD_USINGNAMESPACE = 'usingnamespace' END_OF_WORD ;
KEYWORD_VAR         = 'var'         END_OF_WORD ;
KEYWORD_VOLATILE    = 'volatile'    END_OF_WORD ;
KEYWORD_WHILE       = 'while'       END_OF_WORD ;
 
KEYWORD = KEYWORD_ADDRSPACE | KEYWORD_ALIGN | KEYWORD_ALLOWZERO | KEYWORD_AND
         | KEYWORD_ANYFRAME | KEYWORD_ANYTYPE | KEYWORD_ASM | KEYWORD_ASYNC
         | KEYWORD_AWAIT | KEYWORD_BREAK | KEYWORD_CALLCONV | KEYWORD_CATCH
         | KEYWORD_COMPTIME | KEYWORD_CONST | KEYWORD_CONTINUE | KEYWORD_DEFER
         | KEYWORD_ELSE | KEYWORD_ENUM | KEYWORD_ERRDEFER | KEYWORD_ERROR | KEYWORD_EXPORT
         | KEYWORD_EXTERN | KEYWORD_FN | KEYWORD_FOR | KEYWORD_IF
         | KEYWORD_INLINE | KEYWORD_NOALIAS | KEYWORD_NOSUSPEND | KEYWORD_NOINLINE
         | KEYWORD_OPAQUE | KEYWORD_OR | KEYWORD_ORELSE | KEYWORD_PACKED
         | KEYWORD_PUB | KEYWORD_RESUME | KEYWORD_RETURN | KEYWORD_LINKSECTION
         | KEYWORD_STRUCT | KEYWORD_SUSPEND | KEYWORD_SWITCH | KEYWORD_TEST
         | KEYWORD_THREADLOCAL | KEYWORD_TRY | KEYWORD_UNION | KEYWORD_UNREACHABLE
         | KEYWORD_USINGNAMESPACE | KEYWORD_VAR | KEYWORD_VOLATILE | KEYWORD_WHILE
         ;
