//* This file is part of Zapp, a packrat parser generator.
//* Copyright (C) 2024  Daniel Gr√©vent
//* 
//* This program is free software: you can redistribute it and/or modify
//* it under the terms of the GNU General Public License as published by
//* the Free Software Foundation, either version 3 of the License, or
//* (at your option) any later version.
//* 
//* This program is distributed in the hope that it will be useful,
//* but WITHOUT ANY WARRANTY; without even the implied warranty of
//* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//* GNU General Public License for more details.
//* 
//* You should have received a copy of the GNU General Public License
//* along with this program.  If not, see <https://www.gnu.org/licenses/>.

%% NAME Zapp

%% TOP
const su = @import("string_utils.zig");
const ir = @import("peg_ir.zig");
const PegIr = ir.PegIr;
const PegGrammar = ir.PegGrammar;
const Definition = ir.Definition;
const Sequence = ir.Sequence;
const Action = ir.Action;
const ActionVar = ir.ActionVar;
const Operated = ir.Operated;
const PrefixOp = ir.PrefixOp;
const PostfixOp = ir.PostfixOp;
const Primary = ir.Primary;
const ReturnType = ir.ReturnType;
const Class = ir.Class;
const Range = ir.Range;
const ActionReturn = ir.ActionReturn;
%%

%% FIELDS
ir: PegIr,
%%

Grammar = SPACING (TopLevelComment SPACING )* Name MetaData Definition+ FileEnd {
    self.ir.top_level_comment = invert([]const u8, try $*2.toOwnedSlice());
};

// the metadata
MetaData 
    = TopHeader FieldHeader
    | FieldHeader? TopHeader?
    ;

Name = '%% NAME' SPACING Identifier { self.ir.name = $3; };

TopHeader = TOP_START HeaderInner HEADER_END { 
    self.ir.top_header = $2;  
};
FieldHeader = FIELD_START HeaderInner HEADER_END { 
    self.ir.field_header = $2;  
};

HeaderInner: "[]const u8" = HeaderContent* { $0 };
HeaderContent 
    = !HEADER_END .
    | Literal { self.allocator.free($1); }
    ;

// the metadata
Definition = Identifier TypeAnnotation EQUALS ActionSequence (PIPE ActionSequence)* SEMICOLON {
    _ = $0; // to prevent inlining
    var sequences = $5;
    try sequences.append($4);
    const def_cnt = self.ir.defs.items.len;
    try self.ir.defs.append(.{
        .id = def_cnt,
        .identifier = $1,
        .return_type = $2,
        .sequences = sequences,
        .accepts_eps = false,
        .mid_recurse = false,
        .right_recurse = false,
        .regular = true,
        .finite = true,
        .has_actions = false,
        .moves_actions = false,
        .is_terminal = su.isScreamingSnakeCase($1),
        .generated = false,
    });
};

TypeAnnotation: ReturnType
    = COLON Identifier { ReturnType.init($2, false, false) }
    | COLON Literal { ReturnType.init($2, true, false) }
    | @ { ReturnType.empty() }
    ;

ActionSequence: Sequence 
    = Sequence '{' Action '}' SPACING {
    blk: {
        var seq = $1;
        seq.action = $3;
        break: blk seq;
    }
}
    | Sequence { $1 }
    ;

Sequence: Sequence = Operated+ {.{
    .operateds = $1,
    .string = $0,
    .action = Action.empty(self.ir.allocator),
}};

// START ACTION
Action: Action = ActionParts {.{
    .implicit = false,
    .bases = blk: {
        var bases = std.ArrayList(ir.ActionBase).init(self.ir.allocator);
        try bases.append(.{
            .data = $0,
            .owned = false,
            .action_vars = $1,
            .return_type = ReturnType.impl(),
            .id = 0,
            .mut = false,
        });
        break :blk bases;
    },
    .use_match = blk: {
        for ($1.items) |item| {
            if (!item.isMatchedString()) continue;
            break :blk true;
        }
        break :blk false;
    },
    .rets = std.ArrayList(ActionReturn)
        .init(self.ir.allocator),
}};

// does not accept epsilon
ActionParts: "std.ArrayList(ActionVar)"
        = ActionBlocks '{' ActionParts '}' ActionParts {
    blk: {
        var list = $5;
        try list.appendSlice($1.items);
        try list.appendSlice($3.items);
        $1.deinit();
        $3.deinit();
        break: blk list;
    }
}
    | ActionBlocks  { $1 }
    | @ { std.ArrayList(ActionVar).init(self.ir.allocator) }
    ;

ActionBlocks: "std.ArrayList(ActionVar)" 
    = ActionVar ActionBlocks { blk: { var l = $2; try l.append($1); break :blk l;} }
    | !["'{}$] . ActionBlocks { $3 }
    | Literal ActionBlocks { blk: { self.allocator.free($1); break: blk $2; } }
    | @ { std.ArrayList(ActionVar).init(self.ir.allocator) }
    ;

ActionVar: ActionVar = '$' [0-9] [0-9]*  // immutable variables
{
    blk: {       
        const num = std.fmt.parseInt(usize, $0[1..], 10) catch |err| switch (err) {
            error.InvalidCharacter => unreachable,
            else => {
                self.fail("too large integer!\n", null);
                return;
            },
        };
        break: blk .{
            .var_decl = $0,
            .arg_num = if (num == 0) null else num - 1,
            .escape = false,
        };
    }
}
           | '$*' [1-9] [0-9]*  // mutable variables
{
    blk: {       
        const num = std.fmt.parseInt(usize, $0[2..], 10) catch |err| switch (err) {
            error.InvalidCharacter => unreachable,
            else => {
                self.fail("too large integer!\n", null);
                return;
            },
        };
        break: blk .{
            .var_decl = $0,
            .arg_num = num - 1,
            .escape = true,  // because it is mutable
        };
    }
};
// END ACTION

Operated: Operated = PrefixOp Primary SuffixOp {.{
    .prefix_op = $1,
    .postfix_op = $3,
    .value = $2,
    .return_type = switch ($2) {
        .IDENTIFIER,
        .SEQ,
        => ReturnType.impl(),
        else => ReturnType.empty(),
    },
    .string = std.mem.trimRight(u8, $0, " \t\n\r"),
}};

PrefixOp: PrefixOp 
    = AND { .AND }
    | NOT { .NOT }
    | @ { .NONE }
    ;

SuffixOp: PostfixOp
    = STAR { .STAR }
    | PLUS { .PLUS }
    | QUESTION { .QUESTION }
    | @ { .NONE }
    ;

Primary: Primary
    = OPEN_PAREN Sequence CLOSE_PAREN { .{ .SEQ = $2 } }
    | Identifier { .{ .IDENTIFIER = $1 } }
    | Literal { .{ .LITERAL = $1 } }
    | Class { .{ .CLASS = $1 } }
    | DOT { .DOT }
    | AT { .EPSILON }
    | CUT_OP { .CUT }
    ;

// lexical syntax
Identifier: "[]const u8" = IDENTIFIER SPACING { $1 };
IDENTIFIER: "[]const u8" = IDENT_START IDENT_CONT* { $0 };
IDENT_START = [a-zA-Z_] ;

IDENT_CONT 
    = IDENT_START
    | [0-9]
    ;

Literal: "[]const u8" 
    = ['] (!['] Char)* ['] SPACING { invert(u8, try $*2.toOwnedSlice()) }
    | ["] (!["] Char)* ["] SPACING { invert(u8, try $*2.toOwnedSlice()) }
    ;

Class: Class = '[' (!']' Range)* ']' SPACING { .{ .content = $2 } };

Range: Range = RangeChar '-' RangeChar {.{
    .from = $1,
    .to = $3,
    .backing = $0,
}}
    | RangeChar {.{
    .from = $1,
    .to = 0,
    .backing = $0,
}};

RangeChar: u8 
    = '\\' [-] { '-' }
    | !']' Char { $2 }
    ;

Char: u8 = '\\' [nrt'"\[\]\\] {
    switch ($0[1]) {
        'n' => '\n',
        'r' => '\r',
        't' => '\t',
        else => |c| c, 
    }
}
    // there is no null char allowed 
    | '\\x' [1-9A-Fa-f] [0-9A-Fa-f] {  try std.fmt.parseInt(u8, $0[2..], 16) }
    | '\\x0' [1-9A-Fa-f] { try std.fmt.parseInt(u8, $0[2..], 16) } 
    | !'\\' . { $0[0] }
    ; 

// the terminal Nonterminals
TOP_START = '%% TOP' LINE_END SPACING ;
FIELD_START = '%% FIELDS' LINE_END SPACING ;
HEADER_END = '%%' LINE_END SPACING ;
AT = '@' SPACING ;
DOT = '.' SPACING ;
OPEN_PAREN = '(' SPACING ;
CLOSE_PAREN = ')' SPACING ;
QUESTION = '?' SPACING ;
STAR = '*' SPACING ;
PLUS = '+' SPACING ;
AND = '&' SPACING ;
NOT = '!' SPACING ;
COLON = ':' SPACING ;
PIPE = '|' SPACING ;
EQUALS = '=' SPACING ;
SEMICOLON = ';' SPACING ;
CUT_OP = '^' SPACING ;

//SPACING  
SPACING = SPACE_UNIT* ;

SPACE_UNIT
    = SPACE 
    | COMMENT
    ;

COMMENT = '//' ![*] (!LINE_END .)* LINE_END ;

TopLevelComment: "[]const u8" = '//*' CommentInner LINE_END { $2 }; 

CommentInner: "[]const u8" = (!LINE_END .)* { $0 };

LINE_END 
    = '\r\n'
    | '\n'
    | '\r'
    ;

SPACE 
    = ' '
    | '\t'
    | LINE_END 
    ;

FileEnd = !. ;
