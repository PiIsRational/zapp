// Zapp parser generated by zapp 0.1.0. DO NOT EDIT!

// This file is part of Zapp, a packrat parser generator.
// Copyright (C) 2024  Daniel Gr√©vent
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

const std = @import("std");
const Allocator = std.mem.Allocator;
const assert = std.debug.assert;

const ir = @import("peg_ir.zig");
const PegIr = ir.PegIr;
const PegGrammar = ir.PegGrammar;
const Definition = ir.Definition;
const Sequence = ir.Sequence;
const Action = ir.Action;
const ActionVar = ir.ActionVar;
const Operated = ir.Operated;
const PrefixOp = ir.PrefixOp;
const PostfixOp = ir.PostfixOp;
const Primary = ir.Primary;
const ReturnType = ir.ReturnType;
const Class = ir.Class;
const Range = ir.Range;
const ActionReturn = ir.ActionReturn;

fn invert(comptime T: type, s: []T) []T {
    for (0..@divFloor(s.len, 2)) |i| {
        const j = s.len - 1 - i;
        std.mem.swap(T, &s[i], &s[j]);
    }

    return s;
}

const InferReturnType = union {
    type_2: []const u8,
    type_5: ReturnType,
    type_6: Sequence,
    type_7: Sequence,
    type_8: Action,
    type_9: std.ArrayList(ActionVar),
    type_10: std.ArrayList(ActionVar),
    type_11: ActionVar,
    type_12: Operated,
    type_13: PrefixOp,
    type_14: PostfixOp,
    type_15: Primary,
    type_16: []const u8,
    type_18: []const u8,
    type_19: Range,
    type_20: u8,
    type_21: u8,
    type_24: []const u8,
    type_27: std.ArrayList([]const u8),
    type_29: std.ArrayList(Sequence),
    type_33: std.ArrayList(u8),
    type_34: std.ArrayList(u8),
    type_35: std.ArrayList(Range),
    type_40: std.ArrayList(Operated),
};
pub const ParseReturn = union(enum) {
    pass: void,
    parse_fail: ParsingError,
    infer_fail: InferError,
};

/// the maximal accepted input size for the parser
/// (the -2 is because 0 and 1 represent empty cells and no math cells)
pub const MaxInputSize = std.math.maxInt(u32) - 2;

pub const ParserError = error{
    InputTooLarge,
} || Allocator.Error;

const UseMemo = true;

const EvalFrame = struct {
    stack_start: usize,
    start: usize,
    acc: usize,
    state: usize,
    look: LookType,
    empty_backtrack: bool,
};

pub const ParsingError = struct {
    last_found: []const u8,
    expected: []const u8,
};

pub const InferError = struct {
    err: ?anyerror,
    msg: []const u8,
};

const MemoData = struct {
    state: u32,
    length: u32,
};

const InferInstr = struct {
    state: usize,
    length: usize,
    start: usize,
    memo: bool,
};

const InferFrame = struct {
    acc: usize,
    state: usize,
};

const LookType = struct {
    inverted: bool,
    consuming: bool,
};

pub const Stats = struct {
    /// memory used by the memoization table (in bytes)
    memo: usize,

    /// the memory useage of the parse stack (in bytes)
    parse: usize,

    /// the memory useage of the infer stack (in bytes)
    infer: usize,

    /// the memory useage of the instruction stack (in bytes)
    instr: usize,

    /// the memory useage of the action return stack (in bytes)
    calc: usize,

    /// the maximal memory the memoization table needed (in columns)
    max_memo: usize,

    /// the rule in which the maximal table size was first found
    max_memo_state: usize,

    pub fn format(
        self: Stats,
        comptime _: []const u8,
        _: std.fmt.FormatOptions,
        writer: anytype,
    ) !void {
        try writer.print(
            "memo: {d}\nmax_memo: {d}\nparse: {d}\ninfer: {d}\ninstr: {d}\ncalc: {d}\n",
            .{ self.memo, self.max_memo, self.parse, self.infer, self.instr, self.calc },
        );
    }
};

pub const ParseOptions = struct {
    /// make use of memoization (defaults to true)
    use_memo: bool = true,

    /// set the limit to the parsing stack
    /// per default it is unlimited
    stack_limit: ?usize = null,
};

const NameTable = [_][]const u8{
    "Grammar",
    "MetaData",
    "HeaderInner",
    "HeaderContent",
    "Definition",
    "TypeAnnotation",
    "ActionSequence",
    "Sequence",
    "Action",
    "ActionParts",
    "ActionBlocks",
    "ActionVar",
    "Operated",
    "PrefixOp",
    "SuffixOp",
    "Primary",
    "IDENTIFIER",
    "IdentCont",
    "Literal",
    "Range",
    "RangeChar",
    "Char",
    "HEADER_END",
    "SpaceUnit",
    "CommentInner",
    "LineEnd",
    "Space",
};
const AddrToRule = [_]usize{ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 32, 32, 32, 32, 32, 33, 33, 33, 33, 33, 33, 34, 34, 34, 34, 34, 34, 35, 35, 35, 35, 35, 36, 36, 36, 36, 36, 37, 37, 37, 37, 37, 37, 38, 38, 38, 38, 38, 38, 39, 39, 39, 39, 39, 40, 40, 40, 40, 40, 41, 41, 41, 41, 41, 41, 41, 41, 41, 42, 42, 42, 42, 42, 42, 42, 42, 42 };
const RuleCount = 43;
const AddrToFailState = [_]usize{ 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 293, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 27, 27, 27, 293, 30, 30, 293, 34, 34, 34, 36, 36, 293, 45, 45, 45, 45, 45, 45, 45, 45, 293, 50, 50, 50, 50, 53, 53, 53, 54, 293, 59, 59, 59, 59, 61, 61, 293, 65, 65, 65, 293, 68, 68, 293, 73, 73, 73, 73, 75, 75, 76, 293, 80, 80, 80, 84, 84, 84, 84, 87, 87, 87, 88, 293, 92, 92, 92, 95, 95, 95, 293, 100, 100, 100, 100, 293, 103, 103, 105, 105, 106, 293, 109, 109, 111, 111, 113, 113, 114, 293, 119, 119, 119, 119, 122, 122, 122, 124, 124, 127, 127, 127, 129, 129, 131, 131, 133, 133, 293, 137, 137, 137, 293, 140, 140, 142, 142, 293, 148, 148, 148, 148, 148, 153, 153, 153, 153, 153, 293, 157, 157, 157, 159, 159, 293, 162, 162, 164, 164, 293, 167, 167, 170, 170, 170, 172, 172, 174, 174, 293, 178, 178, 178, 293, 181, 181, 185, 185, 185, 185, 293, 188, 188, 293, 190, 191, 192, 293, 194, 195, 197, 197, 293, 203, 203, 203, 203, 203, 204, 293, 208, 208, 208, 209, 293, 214, 214, 214, 214, 215, 293, 219, 219, 219, 220, 293, 224, 224, 224, 225, 293, 229, 229, 229, 230, 293, 235, 235, 235, 235, 236, 293, 241, 241, 241, 241, 242, 293, 246, 246, 246, 247, 293, 251, 251, 251, 252, 293, 257, 257, 257, 257, 258, 293, 263, 263, 263, 263, 264, 293, 268, 268, 268, 269, 293, 273, 273, 273, 274, 293, 282, 282, 282, 282, 282, 282, 282, 283, 293, 291, 291, 291, 291, 291, 291, 291, 292, 293 };
const ActionTranslate = [_]usize{ 293, 293, 293, 293, 293, 293, 293, 293, 293, 0, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 293, 9, 293, 293, 22, 293, 293, 25, 293, 293, 293, 27, 293, 28, 293, 293, 293, 293, 293, 293, 293, 293, 30, 293, 293, 293, 293, 38, 293, 293, 42, 45, 293, 293, 293, 293, 46, 293, 50, 293, 293, 293, 52, 293, 293, 55, 293, 293, 293, 293, 57, 293, 61, 63, 293, 293, 293, 64, 293, 293, 293, 67, 293, 293, 69, 72, 293, 293, 293, 73, 293, 293, 75, 293, 293, 293, 293, 77, 293, 293, 81, 293, 83, 85, 293, 293, 86, 293, 88, 293, 90, 92, 293, 293, 293, 293, 93, 293, 293, 97, 293, 100, 293, 293, 102, 293, 105, 293, 107, 293, 109, 293, 293, 293, 111, 293, 293, 113, 293, 114, 293, 293, 293, 293, 293, 115, 293, 293, 293, 293, 118, 293, 293, 293, 121, 293, 124, 293, 293, 126, 293, 127, 293, 293, 129, 293, 293, 130, 293, 131, 293, 132, 293, 293, 293, 133, 293, 293, 136, 293, 293, 293, 138, 293, 293, 141, 293, 143, 144, 145, 293, 146, 147, 293, 148, 293, 293, 293, 293, 293, 150, 155, 293, 293, 293, 156, 159, 293, 293, 293, 293, 160, 164, 293, 293, 293, 165, 167, 293, 293, 293, 168, 170, 293, 293, 293, 171, 174, 293, 293, 293, 293, 175, 178, 293, 293, 293, 293, 179, 182, 293, 293, 293, 183, 186, 293, 293, 293, 187, 190, 293, 293, 293, 293, 191, 193, 293, 293, 293, 293, 194, 196, 293, 293, 293, 197, 200, 293, 293, 293, 201, 204, 293, 293, 293, 293, 293, 293, 293, 205, 212, 293, 293, 293, 293, 293, 293, 293, 213, 220, 293 };
const AddrToNFail = [_]bool{ true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, true, true, false, false, false, true, true, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false, false, true, true, false, false, false, false, true, true, true, true, true, true, true, true, true, true, false, false, false, false, false, false, true, true, false, false, false, false, false, false, false, false, false, false, true, true, false, false, false, true, true, true, true, true, true, true, true, true, false, false, false, false, true, true, false, false, false, false, false, false, true, true, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true, true, true, true, true, true, true, false, false, true, true, true, false, false, false, false, false, true, true, true, true, true, true, false, false, false, true, true, true, false, false, true, true, true, false, false, false, false, false, false, false, true, true, true, true, true, true, true, false, false, true, true, true, true, true, true, true, true, false, false, true, true, false, false, true, true, true, false, false, false, false, false, true, true, false, false, false, true, true, false, false, false, false, true, true, false, false, false, true, true, false, false, false, true, true, false, false, false, true, true, false, false, false, false, true, true, false, false, false, false, true, true, false, false, false, true, true, false, false, false, true, true, false, false, false, false, true, true, false, false, false, false, true, true, false, false, false, true, true, false, false, false, true, true, false, false, false, false, false, false, false, true, true, false, false, false, false, false, false, false, true, true };
pub fn Zapp(comptime opts: ParseOptions) type {
    return struct {
        chars: [:0]const u8,
        allocator: Allocator,
        stack: std.ArrayList(EvalFrame),
        stack_alloc: ?std.heap.FixedBufferAllocator,
        infer_stack: std.ArrayList(InferFrame),
        calc_stack: std.ArrayList(InferReturnType),
        memo: std.ArrayList([RuleCount]MemoData),
        infer_actions: std.ArrayList(InferInstr),
        infer_instrs: std.ArrayList(InferInstr),
        memo_start: usize,
        start: usize,
        acc: usize,
        infer_acc: usize,
        infer_done: bool,
        fail: bool,
        state: usize,
        infer_state: usize,
        infer_start: usize,
        stack_start: usize,
        empty_backtrack: bool,
        max_reached: usize,
        max_slice: []const u8,
        next_expected: usize,
        max_memo: usize,
        max_memo_state: usize,
        infer_fail_msg: []const u8,
        infer_fail_err: ?anyerror,

        ir: PegIr,

        pub fn init(allocator: Allocator) Allocator.Error!@This() {
            var self: @This() = undefined;
            self.allocator = allocator;
            if (opts.stack_limit) |limit| {
                var stack_alloc = std.heap.FixedBufferAllocator
                    .init(try self.allocator.alloc(u8, @sizeOf(EvalFrame) * limit));
                self.stack = std.ArrayList(EvalFrame)
                    .init(stack_alloc.allocator());
                try self.stack.ensureTotalCapacity(limit);
                self.stack_alloc = stack_alloc;
            } else {
                self.stack_alloc = null;
                self.stack = std.ArrayList(EvalFrame).init(allocator);
            }
            self.infer_stack = std.ArrayList(InferFrame).init(allocator);
            self.memo = std.ArrayList([RuleCount]MemoData).init(allocator);
            self.calc_stack = std.ArrayList(InferReturnType).init(allocator);
            self.infer_actions = std.ArrayList(InferInstr).init(allocator);
            self.infer_instrs = std.ArrayList(InferInstr).init(allocator);
            self.reset("");
            return self;
        }

        pub fn deinit(self: *@This()) void {
            self.infer_actions.deinit();
            self.infer_instrs.deinit();
            self.stack.deinit();
            if (self.stack_alloc) |allocator| {
                self.allocator.free(allocator.buffer);
            }
            self.infer_stack.deinit();
            self.memo.deinit();
            self.calc_stack.deinit();
        }

        fn reset(self: *@This(), chars: [:0]const u8) void {
            assert(self.stack.items.len == 0);
            assert(self.infer_stack.items.len == 0);
            assert(self.calc_stack.items.len == 0);
            self.infer_actions.clearRetainingCapacity();
            self.infer_instrs.clearRetainingCapacity();
            self.memo.clearRetainingCapacity();
            self.state = 0;
            self.infer_state = 0;
            self.infer_start = 0;
            self.memo_start = 0;
            self.stack_start = 0;
            self.start = 0;
            self.acc = 0;
            self.infer_acc = 0;
            self.infer_done = false;
            self.fail = false;
            self.max_reached = 0;
            self.max_slice = "";
            self.next_expected = 0;
            self.infer_fail_msg = "";
            self.infer_fail_err = null;
            self.empty_backtrack = AddrToNFail[0];
            self.max_memo = 0;
            self.max_memo_state = 0;
            self.chars = chars;
        }

        pub fn stats(self: *@This()) Stats {
            return .{
                .memo = self.memo.capacity * @sizeOf([RuleCount]MemoData),
                .max_memo = self.max_memo,
                .parse = self.stack.capacity * @sizeOf(EvalFrame),
                .infer = self.infer_stack.capacity * @sizeOf(InferFrame),
                .instr = self.infer_instrs.capacity * @sizeOf(InferInstr),
                .calc = self.calc_stack.capacity * @sizeOf(InferReturnType),
                .max_memo_state = AddrToRule[self.max_memo_state],
            };
        }

        fn parseNonterminal(
            self: *@This(),
            comptime state: usize,
            comptime inverted: bool,
            comptime consuming: bool,
        ) Allocator.Error!void {
            if (opts.use_memo) try self.adjustBacktrack();
            try self.stack.append(.{
                .start = self.start,
                .acc = self.acc,
                .state = self.state,
                .stack_start = self.stack_start + self.memo_start,
                .look = .{
                    .inverted = inverted,
                    .consuming = consuming,
                },
                .empty_backtrack = self.empty_backtrack,
            });

            self.stack_start = self.infer_actions.items.len;
            self.start += self.acc;
            self.state = state;
            self.acc = 0;
            self.empty_backtrack = AddrToNFail[self.state] and
                self.empty_backtrack and consuming;

            if (!opts.use_memo) return;
            if (self.start + self.acc >= self.memo.items.len + self.memo_start or
                self.memo.items[
                self.start + self.acc - self.memo_start
            ][AddrToRule[state]].length == 0) {
                return;
            }

            const value = self.memo.items[
                self.start + self.acc - self.memo_start
            ][AddrToRule[state]];

            self.state = value.state;
            if (value.length == 1) {
                try self.returnFromNonterminal(true, true);
            } else {
                self.acc = value.length - 2;
                try self.returnFromNonterminal(false, true);
            }
        }

        fn returnFromNonterminal(
            self: *@This(),
            comptime failed: bool,
            comptime memo: bool,
        ) Allocator.Error!void {
            const frame = self.stack.popOrNull() orelse blk: {
                self.fail = failed;
                break :blk EvalFrame{
                    .stack_start = 0,
                    .start = self.start,
                    .acc = 0,
                    .state = self.state,
                    .look = .{
                        .inverted = false,
                        .consuming = true,
                    },
                    .empty_backtrack = AddrToNFail[self.state],
                };
            };

            const look = frame.look;
            const good = failed == look.inverted;

            if (!failed and look.consuming and self.max_reached <= self.start + self.acc and
                (self.max_reached < self.start + self.acc or self.acc > self.max_slice.len))
            {
                self.max_slice = self.chars[self.start .. self.start + self.acc];
                self.max_reached = self.start + self.acc;
            } else if (self.max_reached == self.start) {
                self.next_expected = self.state;
            }

            if (opts.use_memo) {
                if (self.start >= self.memo.items.len + self.memo_start) {
                    try self.memo.appendNTimes(
                        [1]MemoData{.{ .length = 0, .state = 0 }} ** RuleCount,
                        self.start + 1 - self.memo.items.len - self.memo_start,
                    );
                }

                if (self.memo_start <= self.start and self.memo.items[
                    self.start - self.memo_start
                ][AddrToRule[self.state]].length == 0) {
                    self.memo.items[
                        self.start - self.memo_start
                    ][AddrToRule[self.state]] = if (failed)
                        .{ .length = 1, .state = @intCast(self.state) }
                    else
                        .{ .length = 2 + @as(u32, @intCast(self.acc)), .state = @intCast(self.state) };
                }
            }

            if (look.consuming and good) {
                try self.infer_actions.append(.{
                    .length = self.acc,
                    .state = self.state,
                    .start = self.start,
                    .memo = memo,
                });
                self.acc += frame.acc;
                self.state = frame.state + 1;
            } else if (good) {
                self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                self.acc = frame.acc;
                self.state = frame.state + 1;
            } else {
                if (frame.stack_start >= self.memo_start) {
                    self.infer_actions.shrinkRetainingCapacity(
                        frame.stack_start - self.memo_start,
                    );
                }
                self.acc = 0;
                self.state = AddrToFailState[frame.state];
            }

            self.stack_start = frame.stack_start - @min(frame.stack_start, self.memo_start);
            self.start = frame.start;
            if (opts.use_memo) {
                if (frame.empty_backtrack) {
                    self.empty_backtrack = true;
                    if (self.empty_backtrack) try self.resetMemo(self.acc + self.start);
                } else try self.adjustBacktrack();
            }
        }

        fn adjustBacktrack(self: *@This()) Allocator.Error!void {
            if (self.stack.getLastOrNull()) |parent| {
                self.empty_backtrack = parent.empty_backtrack and AddrToNFail[self.state] and parent.look.consuming;
                if (self.empty_backtrack) try self.resetMemo(self.acc + self.start);
            } else {
                self.empty_backtrack = AddrToNFail[self.state];
                if (self.empty_backtrack) try self.resetMemo(self.acc + self.start);
            }
        }

        fn getParseError(self: @This()) ParsingError {
            const rule = AddrToRule[self.next_expected];
            return .{
                .last_found = self.max_slice,
                .expected = if (rule < NameTable.len)
                    NameTable[rule]
                else
                    "",
            };
        }

        fn resetMemo(self: *@This(), new_begin: usize) Allocator.Error!void {
            try self.finalizeInferInstrs();
            if (new_begin < self.memo_start) {
                self.fail = true;
                return;
            }
            if (self.memo.items.len > self.max_memo) {
                self.max_memo = self.memo.items.len;
                self.max_memo_state = self.state;
            }
            const new_start = new_begin - self.memo_start;
            if (new_start < self.memo.items.len) {
                std.mem.copyForwards(
                    [RuleCount]MemoData,
                    self.memo.items,
                    self.memo.items[new_start..],
                );
                self.memo.shrinkRetainingCapacity(self.memo.items.len - new_start);
            } else {
                self.memo.clearRetainingCapacity();
            }
            self.memo_start = new_begin;
        }
        pub fn parse(
            self: *@This(),
            chars: [:0]const u8,
        ) ParserError!ParseReturn {
            if (chars.len > MaxInputSize) {
                return error.InputTooLarge;
            }

            self.reset(chars);

            while (true) {
                switch (self.state) {
                    0 => {
                        try self.parseNonterminal(248, false, true);
                    },
                    1 => {
                        try self.parseNonterminal(198, false, true);
                    },
                    2 => {
                        if (self.chars.len >= self.start + 7 + self.acc and
                            std.mem.eql(u8, "%% NAME", self
                            .chars[self.start + self.acc .. self.start + self.acc + 7]))
                        {
                            self.acc += 7;
                        } else {
                            self.state = 10;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.parseNonterminal(248, false, true);
                    },
                    3 => {
                        try self.parseNonterminal(134, false, true);
                    },
                    4 => {
                        try self.parseNonterminal(248, false, true);
                    },
                    5 => {
                        try self.parseNonterminal(11, false, true);
                    },
                    6 => {
                        try self.parseNonterminal(37, false, true);
                    },
                    7 => {
                        try self.parseNonterminal(265, false, true);
                    },
                    8 => {
                        switch (self.chars[self.acc + self.start]) {
                            '\x00',
                            => {
                                self.state = 9;
                            },
                            '\x01'...'\xff',
                            => {
                                self.state = 10;
                                self.acc = 0;
                                self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                                continue;
                            },
                        }
                    },
                    9 => {
                        try self.returnFromNonterminal(false, false);
                        break;
                    },
                    10 => {
                        try self.returnFromNonterminal(true, false);
                        break;
                    },
                    11 => {
                        if (self.chars.len >= self.start + 6 + self.acc and
                            std.mem.eql(u8, "%% TOP", self
                            .chars[self.start + self.acc .. self.start + self.acc + 6]))
                        {
                            self.acc += 6;
                        } else {
                            self.state = 24;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.parseNonterminal(189, false, true);
                    },
                    12 => {
                        try self.parseNonterminal(248, false, true);
                    },
                    13 => {
                        try self.parseNonterminal(28, false, true);
                    },
                    14 => {
                        if (self.chars.len >= self.start + 2 + self.acc and
                            std.mem.eql(u8, "%%", self
                            .chars[self.start + self.acc .. self.start + self.acc + 2]))
                        {
                            self.acc += 2;
                        } else {
                            self.state = 24;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.parseNonterminal(189, false, true);
                    },
                    15 => {
                        try self.parseNonterminal(248, false, true);
                    },
                    16 => {
                        try self.parseNonterminal(248, false, true);
                    },
                    17 => {
                        if (self.chars.len >= self.start + 9 + self.acc and
                            std.mem.eql(u8, "%% FIELDS", self
                            .chars[self.start + self.acc .. self.start + self.acc + 9]))
                        {
                            self.acc += 9;
                        } else {
                            self.state = 24;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.parseNonterminal(189, false, true);
                    },
                    18 => {
                        try self.parseNonterminal(248, false, true);
                    },
                    19 => {
                        try self.parseNonterminal(28, false, true);
                    },
                    20 => {
                        if (self.chars.len >= self.start + 2 + self.acc and
                            std.mem.eql(u8, "%%", self
                            .chars[self.start + self.acc .. self.start + self.acc + 2]))
                        {
                            self.acc += 2;
                        } else {
                            self.state = 24;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.parseNonterminal(189, false, true);
                    },
                    21 => {
                        try self.parseNonterminal(248, false, true);
                    },
                    22 => {
                        try self.parseNonterminal(248, false, true);
                    },
                    23 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    24 => {
                        try self.parseNonterminal(284, false, true);
                    },
                    25 => {
                        try self.parseNonterminal(275, false, true);
                    },
                    26 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    27 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    28 => {
                        try self.parseNonterminal(205, false, true);
                    },
                    29 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    30 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    31 => {
                        try self.parseNonterminal(175, true, false);
                    },
                    32 => {
                        switch (self.chars[self.acc + self.start]) {
                            '\x01'...'\xff',
                            => {
                                self.state = 33;
                                self.acc += 1;
                            },
                            '\x00',
                            => {
                                self.state = 34;
                                self.acc = 0;
                                self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                                continue;
                            },
                        }
                    },
                    33 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    34 => {
                        try self.parseNonterminal(143, false, true);
                    },
                    35 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    36 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    37 => {
                        try self.parseNonterminal(134, false, true);
                    },
                    38 => {
                        try self.parseNonterminal(248, false, true);
                    },
                    39 => {
                        try self.parseNonterminal(46, false, true);
                    },
                    40 => {
                        if (self.chars.len >= self.start + 1 + self.acc and
                            std.mem.eql(u8, "=", self
                            .chars[self.start + self.acc .. self.start + self.acc + 1]))
                        {
                            self.acc += 1;
                        } else {
                            self.state = 45;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.parseNonterminal(248, false, true);
                    },
                    41 => {
                        try self.parseNonterminal(55, false, true);
                    },
                    42 => {
                        try self.parseNonterminal(210, false, true);
                    },
                    43 => {
                        if (self.chars.len >= self.start + 1 + self.acc and
                            std.mem.eql(u8, ";", self
                            .chars[self.start + self.acc .. self.start + self.acc + 1]))
                        {
                            self.acc += 1;
                        } else {
                            self.state = 45;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.parseNonterminal(248, false, true);
                    },
                    44 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    45 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    46 => {
                        if (self.chars.len >= self.start + 1 + self.acc and
                            std.mem.eql(u8, ":", self
                            .chars[self.start + self.acc .. self.start + self.acc + 1]))
                        {
                            self.acc += 1;
                        } else {
                            self.state = 50;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.parseNonterminal(248, false, true);
                    },
                    47 => {
                        try self.parseNonterminal(134, false, true);
                    },
                    48 => {
                        try self.parseNonterminal(248, false, true);
                    },
                    49 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    50 => {
                        if (self.chars.len >= self.start + 1 + self.acc and
                            std.mem.eql(u8, ":", self
                            .chars[self.start + self.acc .. self.start + self.acc + 1]))
                        {
                            self.acc += 1;
                        } else {
                            self.state = 53;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.parseNonterminal(248, false, true);
                    },
                    51 => {
                        try self.parseNonterminal(143, false, true);
                    },
                    52 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    53 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    54 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    55 => {
                        try self.parseNonterminal(62, false, true);
                    },
                    56 => {
                        if (self.chars.len >= self.start + 1 + self.acc and
                            std.mem.eql(u8, "{", self
                            .chars[self.start + self.acc .. self.start + self.acc + 1]))
                        {
                            self.acc += 1;
                        } else {
                            self.state = 59;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.parseNonterminal(66, false, true);
                    },
                    57 => {
                        if (self.chars.len >= self.start + 1 + self.acc and
                            std.mem.eql(u8, "}", self
                            .chars[self.start + self.acc .. self.start + self.acc + 1]))
                        {
                            self.acc += 1;
                        } else {
                            self.state = 59;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.parseNonterminal(248, false, true);
                    },
                    58 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    59 => {
                        try self.parseNonterminal(62, false, true);
                    },
                    60 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    61 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    62 => {
                        try self.parseNonterminal(96, false, true);
                    },
                    63 => {
                        try self.parseNonterminal(270, false, true);
                    },
                    64 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    65 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    66 => {
                        try self.parseNonterminal(69, false, true);
                    },
                    67 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    68 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    69 => {
                        try self.parseNonterminal(77, false, true);
                    },
                    70 => {
                        if (self.chars.len >= self.start + 1 + self.acc and
                            std.mem.eql(u8, "{", self
                            .chars[self.start + self.acc .. self.start + self.acc + 1]))
                        {
                            self.acc += 1;
                        } else {
                            self.state = 73;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.parseNonterminal(69, false, true);
                    },
                    71 => {
                        if (self.chars.len >= self.start + 1 + self.acc and
                            std.mem.eql(u8, "}", self
                            .chars[self.start + self.acc .. self.start + self.acc + 1]))
                        {
                            self.acc += 1;
                        } else {
                            self.state = 73;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.parseNonterminal(69, false, true);
                    },
                    72 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    73 => {
                        try self.parseNonterminal(77, false, true);
                    },
                    74 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    75 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    76 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    77 => {
                        try self.parseNonterminal(89, false, true);
                    },
                    78 => {
                        try self.parseNonterminal(77, false, true);
                    },
                    79 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    80 => {
                        switch (self.chars[self.acc + self.start]) {
                            '\x00'...'!',
                            '#',
                            '%'...'&',
                            '('...'z',
                            '|',
                            '~'...'\xff',
                            => {
                                self.state = 81;
                            },
                            '\"',
                            '$',
                            '\'',
                            '{',
                            '}',
                            => {
                                self.state = 84;
                                self.acc = 0;
                                self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                                continue;
                            },
                        }
                    },
                    81 => {
                        switch (self.chars[self.acc + self.start]) {
                            '\x01'...'\xff',
                            => {
                                self.state = 82;
                                self.acc += 1;
                            },
                            '\x00',
                            => {
                                self.state = 84;
                                self.acc = 0;
                                self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                                continue;
                            },
                        }
                    },
                    82 => {
                        try self.parseNonterminal(77, false, true);
                    },
                    83 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    84 => {
                        try self.parseNonterminal(143, false, true);
                    },
                    85 => {
                        try self.parseNonterminal(77, false, true);
                    },
                    86 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    87 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    88 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    89 => {
                        if (self.chars.len >= self.start + 1 + self.acc and
                            std.mem.eql(u8, "$", self
                            .chars[self.start + self.acc .. self.start + self.acc + 1]))
                        {
                            self.acc += 1;
                        } else {
                            self.state = 92;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        switch (self.chars[self.acc + self.start]) {
                            '0'...'9',
                            => {
                                self.state = 90;
                                self.acc += 1;
                            },
                            '\x00'...'/',
                            ':'...'\xff',
                            => {
                                self.state = 92;
                                self.acc = 0;
                                self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                                continue;
                            },
                        }
                    },
                    90 => {
                        try self.parseNonterminal(221, false, true);
                    },
                    91 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    92 => {
                        if (self.chars.len >= self.start + 2 + self.acc and
                            std.mem.eql(u8, "$*", self
                            .chars[self.start + self.acc .. self.start + self.acc + 2]))
                        {
                            self.acc += 2;
                        } else {
                            self.state = 95;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        switch (self.chars[self.acc + self.start]) {
                            '1'...'9',
                            => {
                                self.state = 93;
                                self.acc += 1;
                            },
                            '\x00'...'0',
                            ':'...'\xff',
                            => {
                                self.state = 95;
                                self.acc = 0;
                                self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                                continue;
                            },
                        }
                    },
                    93 => {
                        try self.parseNonterminal(216, false, true);
                    },
                    94 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    95 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    96 => {
                        try self.parseNonterminal(101, false, true);
                    },
                    97 => {
                        try self.parseNonterminal(115, false, true);
                    },
                    98 => {
                        try self.parseNonterminal(107, false, true);
                    },
                    99 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    100 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    101 => {
                        if (self.chars.len >= self.start + 1 + self.acc and
                            std.mem.eql(u8, "&", self
                            .chars[self.start + self.acc .. self.start + self.acc + 1]))
                        {
                            self.acc += 1;
                        } else {
                            self.state = 103;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.parseNonterminal(248, false, true);
                    },
                    102 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    103 => {
                        if (self.chars.len >= self.start + 1 + self.acc and
                            std.mem.eql(u8, "!", self
                            .chars[self.start + self.acc .. self.start + self.acc + 1]))
                        {
                            self.acc += 1;
                        } else {
                            self.state = 105;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.parseNonterminal(248, false, true);
                    },
                    104 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    105 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    106 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    107 => {
                        if (self.chars.len >= self.start + 1 + self.acc and
                            std.mem.eql(u8, "*", self
                            .chars[self.start + self.acc .. self.start + self.acc + 1]))
                        {
                            self.acc += 1;
                        } else {
                            self.state = 109;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.parseNonterminal(248, false, true);
                    },
                    108 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    109 => {
                        if (self.chars.len >= self.start + 1 + self.acc and
                            std.mem.eql(u8, "+", self
                            .chars[self.start + self.acc .. self.start + self.acc + 1]))
                        {
                            self.acc += 1;
                        } else {
                            self.state = 111;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.parseNonterminal(248, false, true);
                    },
                    110 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    111 => {
                        if (self.chars.len >= self.start + 1 + self.acc and
                            std.mem.eql(u8, "?", self
                            .chars[self.start + self.acc .. self.start + self.acc + 1]))
                        {
                            self.acc += 1;
                        } else {
                            self.state = 113;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.parseNonterminal(248, false, true);
                    },
                    112 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    113 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    114 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    115 => {
                        if (self.chars.len >= self.start + 1 + self.acc and
                            std.mem.eql(u8, "(", self
                            .chars[self.start + self.acc .. self.start + self.acc + 1]))
                        {
                            self.acc += 1;
                        } else {
                            self.state = 119;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.parseNonterminal(248, false, true);
                    },
                    116 => {
                        try self.parseNonterminal(62, false, true);
                    },
                    117 => {
                        if (self.chars.len >= self.start + 1 + self.acc and
                            std.mem.eql(u8, ")", self
                            .chars[self.start + self.acc .. self.start + self.acc + 1]))
                        {
                            self.acc += 1;
                        } else {
                            self.state = 119;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.parseNonterminal(248, false, true);
                    },
                    118 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    119 => {
                        try self.parseNonterminal(134, false, true);
                    },
                    120 => {
                        try self.parseNonterminal(248, false, true);
                    },
                    121 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    122 => {
                        try self.parseNonterminal(143, false, true);
                    },
                    123 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    124 => {
                        if (self.chars.len >= self.start + 1 + self.acc and
                            std.mem.eql(u8, "[", self
                            .chars[self.start + self.acc .. self.start + self.acc + 1]))
                        {
                            self.acc += 1;
                        } else {
                            self.state = 127;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.parseNonterminal(243, false, true);
                    },
                    125 => {
                        if (self.chars.len >= self.start + 1 + self.acc and
                            std.mem.eql(u8, "]", self
                            .chars[self.start + self.acc .. self.start + self.acc + 1]))
                        {
                            self.acc += 1;
                        } else {
                            self.state = 127;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.parseNonterminal(248, false, true);
                    },
                    126 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    127 => {
                        if (self.chars.len >= self.start + 1 + self.acc and
                            std.mem.eql(u8, ".", self
                            .chars[self.start + self.acc .. self.start + self.acc + 1]))
                        {
                            self.acc += 1;
                        } else {
                            self.state = 129;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.parseNonterminal(248, false, true);
                    },
                    128 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    129 => {
                        if (self.chars.len >= self.start + 1 + self.acc and
                            std.mem.eql(u8, "@", self
                            .chars[self.start + self.acc .. self.start + self.acc + 1]))
                        {
                            self.acc += 1;
                        } else {
                            self.state = 131;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.parseNonterminal(248, false, true);
                    },
                    130 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    131 => {
                        if (self.chars.len >= self.start + 1 + self.acc and
                            std.mem.eql(u8, "^", self
                            .chars[self.start + self.acc .. self.start + self.acc + 1]))
                        {
                            self.acc += 1;
                        } else {
                            self.state = 133;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.parseNonterminal(248, false, true);
                    },
                    132 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    133 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    134 => {
                        switch (self.chars[self.acc + self.start]) {
                            '_',
                            'A'...'Z',
                            'a'...'z',
                            => {
                                self.state = 135;
                                self.acc += 1;
                            },
                            '\x00'...'@',
                            '['...'^',
                            '`',
                            '{'...'\xff',
                            => {
                                self.state = 137;
                                self.acc = 0;
                                self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                                continue;
                            },
                        }
                    },
                    135 => {
                        try self.parseNonterminal(226, false, true);
                    },
                    136 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    137 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    138 => {
                        switch (self.chars[self.acc + self.start]) {
                            '_',
                            'A'...'Z',
                            'a'...'z',
                            => {
                                self.state = 139;
                                self.acc += 1;
                            },
                            '\x00'...'@',
                            '['...'^',
                            '`',
                            '{'...'\xff',
                            => {
                                self.state = 140;
                                self.acc = 0;
                                self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                                continue;
                            },
                        }
                    },
                    139 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    140 => {
                        switch (self.chars[self.acc + self.start]) {
                            '0'...'9',
                            => {
                                self.state = 141;
                                self.acc += 1;
                            },
                            '\x00'...'/',
                            ':'...'\xff',
                            => {
                                self.state = 142;
                                self.acc = 0;
                                self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                                continue;
                            },
                        }
                    },
                    141 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    142 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    143 => {
                        switch (self.chars[self.acc + self.start]) {
                            '\'',
                            => {
                                self.state = 144;
                                self.acc += 1;
                            },
                            '\x00'...'&',
                            '('...'\xff',
                            => {
                                self.state = 148;
                                self.acc = 0;
                                self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                                continue;
                            },
                        }
                    },
                    144 => {
                        try self.parseNonterminal(237, false, true);
                    },
                    145 => {
                        switch (self.chars[self.acc + self.start]) {
                            '\'',
                            => {
                                self.state = 146;
                                self.acc += 1;
                            },
                            '\x00'...'&',
                            '('...'\xff',
                            => {
                                self.state = 148;
                                self.acc = 0;
                                self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                                continue;
                            },
                        }
                    },
                    146 => {
                        try self.parseNonterminal(248, false, true);
                    },
                    147 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    148 => {
                        switch (self.chars[self.acc + self.start]) {
                            '\"',
                            => {
                                self.state = 149;
                                self.acc += 1;
                            },
                            '\x00'...'!',
                            '#'...'\xff',
                            => {
                                self.state = 153;
                                self.acc = 0;
                                self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                                continue;
                            },
                        }
                    },
                    149 => {
                        try self.parseNonterminal(231, false, true);
                    },
                    150 => {
                        switch (self.chars[self.acc + self.start]) {
                            '\"',
                            => {
                                self.state = 151;
                                self.acc += 1;
                            },
                            '\x00'...'!',
                            '#'...'\xff',
                            => {
                                self.state = 153;
                                self.acc = 0;
                                self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                                continue;
                            },
                        }
                    },
                    151 => {
                        try self.parseNonterminal(248, false, true);
                    },
                    152 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    153 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    154 => {
                        try self.parseNonterminal(160, false, true);
                    },
                    155 => {
                        if (self.chars.len >= self.start + 1 + self.acc and
                            std.mem.eql(u8, "-", self
                            .chars[self.start + self.acc .. self.start + self.acc + 1]))
                        {
                            self.acc += 1;
                        } else {
                            self.state = 157;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.parseNonterminal(160, false, true);
                    },
                    156 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    157 => {
                        try self.parseNonterminal(160, false, true);
                    },
                    158 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    159 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    160 => {
                        if (self.chars.len >= self.start + 1 + self.acc and
                            std.mem.eql(u8, "\\", self
                            .chars[self.start + self.acc .. self.start + self.acc + 1]))
                        {
                            self.acc += 1;
                        } else {
                            self.state = 162;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        switch (self.chars[self.acc + self.start]) {
                            '-',
                            => {
                                self.state = 161;
                                self.acc += 1;
                            },
                            '\x00'...',',
                            '.'...'\xff',
                            => {
                                self.state = 162;
                                self.acc = 0;
                                self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                                continue;
                            },
                        }
                    },
                    161 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    162 => {
                        if (self.chars.len >= self.start + 1 + self.acc and
                            !std.mem.eql(u8, "]", self
                            .chars[self.start + self.acc .. self.start + self.acc + 1]))
                        {} else {
                            self.state = 164;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.parseNonterminal(165, false, true);
                    },
                    163 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    164 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    165 => {
                        if (self.chars.len >= self.start + 1 + self.acc and
                            std.mem.eql(u8, "\\", self
                            .chars[self.start + self.acc .. self.start + self.acc + 1]))
                        {
                            self.acc += 1;
                        } else {
                            self.state = 167;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        switch (self.chars[self.acc + self.start]) {
                            '\\',
                            ']',
                            '[',
                            '\"',
                            '\'',
                            't',
                            'r',
                            'n',
                            => {
                                self.state = 166;
                                self.acc += 1;
                            },
                            '\x00'...'!',
                            '#'...'&',
                            '('...'Z',
                            '^'...'m',
                            'o'...'q',
                            's',
                            'u'...'\xff',
                            => {
                                self.state = 167;
                                self.acc = 0;
                                self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                                continue;
                            },
                        }
                    },
                    166 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    167 => {
                        if (self.chars.len >= self.start + 2 + self.acc and
                            std.mem.eql(u8, "\\x", self
                            .chars[self.start + self.acc .. self.start + self.acc + 2]))
                        {
                            self.acc += 2;
                        } else {
                            self.state = 170;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        switch (self.chars[self.acc + self.start]) {
                            'a'...'f',
                            'A'...'F',
                            '1'...'9',
                            => {
                                self.state = 168;
                                self.acc += 1;
                            },
                            '\x00'...'0',
                            ':'...'@',
                            'G'...'`',
                            'g'...'\xff',
                            => {
                                self.state = 170;
                                self.acc = 0;
                                self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                                continue;
                            },
                        }
                    },
                    168 => {
                        switch (self.chars[self.acc + self.start]) {
                            'a'...'f',
                            'A'...'F',
                            '0'...'9',
                            => {
                                self.state = 169;
                                self.acc += 1;
                            },
                            '\x00'...'/',
                            ':'...'@',
                            'G'...'`',
                            'g'...'\xff',
                            => {
                                self.state = 170;
                                self.acc = 0;
                                self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                                continue;
                            },
                        }
                    },
                    169 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    170 => {
                        if (self.chars.len >= self.start + 3 + self.acc and
                            std.mem.eql(u8, "\\x0", self
                            .chars[self.start + self.acc .. self.start + self.acc + 3]))
                        {
                            self.acc += 3;
                        } else {
                            self.state = 172;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        switch (self.chars[self.acc + self.start]) {
                            'a'...'f',
                            'A'...'F',
                            '1'...'9',
                            => {
                                self.state = 171;
                                self.acc += 1;
                            },
                            '\x00'...'0',
                            ':'...'@',
                            'G'...'`',
                            'g'...'\xff',
                            => {
                                self.state = 172;
                                self.acc = 0;
                                self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                                continue;
                            },
                        }
                    },
                    171 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    172 => {
                        if (self.chars.len >= self.start + 1 + self.acc and
                            !std.mem.eql(u8, "\\", self
                            .chars[self.start + self.acc .. self.start + self.acc + 1]))
                        {} else {
                            self.state = 174;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        switch (self.chars[self.acc + self.start]) {
                            '\x01'...'\xff',
                            => {
                                self.state = 173;
                                self.acc += 1;
                            },
                            '\x00',
                            => {
                                self.state = 174;
                                self.acc = 0;
                                self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                                continue;
                            },
                        }
                    },
                    173 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    174 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    175 => {
                        if (self.chars.len >= self.start + 2 + self.acc and
                            std.mem.eql(u8, "%%", self
                            .chars[self.start + self.acc .. self.start + self.acc + 2]))
                        {
                            self.acc += 2;
                        } else {
                            self.state = 178;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.parseNonterminal(189, false, true);
                    },
                    176 => {
                        try self.parseNonterminal(248, false, true);
                    },
                    177 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    178 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    179 => {
                        try self.parseNonterminal(193, false, true);
                    },
                    180 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    181 => {
                        if (self.chars.len >= self.start + 2 + self.acc and
                            std.mem.eql(u8, "//", self
                            .chars[self.start + self.acc .. self.start + self.acc + 2]))
                        {
                            self.acc += 2;
                        } else {
                            self.state = 185;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        switch (self.chars[self.acc + self.start]) {
                            '\x00'...')',
                            '+'...'\xff',
                            => {
                                self.state = 182;
                            },
                            '*',
                            => {
                                self.state = 185;
                                self.acc = 0;
                                self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                                continue;
                            },
                        }
                    },
                    182 => {
                        try self.parseNonterminal(253, false, true);
                    },
                    183 => {
                        try self.parseNonterminal(189, false, true);
                    },
                    184 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    185 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    186 => {
                        try self.parseNonterminal(259, false, true);
                    },
                    187 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    188 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    189 => {
                        if (self.chars.len >= self.start + 2 + self.acc and
                            std.mem.eql(u8, "\r\n", self
                            .chars[self.start + self.acc .. self.start + self.acc + 2]))
                        {
                            self.acc += 2;
                        } else {
                            self.state = 190;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.returnFromNonterminal(false, false);
                    },
                    190 => {
                        if (self.chars.len >= self.start + 1 + self.acc and
                            std.mem.eql(u8, "\n", self
                            .chars[self.start + self.acc .. self.start + self.acc + 1]))
                        {
                            self.acc += 1;
                        } else {
                            self.state = 191;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.returnFromNonterminal(false, false);
                    },
                    191 => {
                        if (self.chars.len >= self.start + 1 + self.acc and
                            std.mem.eql(u8, "\r", self
                            .chars[self.start + self.acc .. self.start + self.acc + 1]))
                        {
                            self.acc += 1;
                        } else {
                            self.state = 192;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.returnFromNonterminal(false, false);
                    },
                    192 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    193 => {
                        if (self.chars.len >= self.start + 1 + self.acc and
                            std.mem.eql(u8, " ", self
                            .chars[self.start + self.acc .. self.start + self.acc + 1]))
                        {
                            self.acc += 1;
                        } else {
                            self.state = 194;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.returnFromNonterminal(false, false);
                    },
                    194 => {
                        if (self.chars.len >= self.start + 1 + self.acc and
                            std.mem.eql(u8, "\t", self
                            .chars[self.start + self.acc .. self.start + self.acc + 1]))
                        {
                            self.acc += 1;
                        } else {
                            self.state = 195;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.returnFromNonterminal(false, false);
                    },
                    195 => {
                        try self.parseNonterminal(189, false, true);
                    },
                    196 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    197 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    198 => {
                        if (self.chars.len >= self.start + 3 + self.acc and
                            std.mem.eql(u8, "//*", self
                            .chars[self.start + self.acc .. self.start + self.acc + 3]))
                        {
                            self.acc += 3;
                        } else {
                            self.state = 203;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.parseNonterminal(186, false, true);
                    },
                    199 => {
                        try self.parseNonterminal(189, false, true);
                    },
                    200 => {
                        try self.parseNonterminal(248, false, true);
                    },
                    201 => {
                        try self.parseNonterminal(198, false, true);
                    },
                    202 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    203 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    204 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    205 => {
                        try self.parseNonterminal(31, false, true);
                    },
                    206 => {
                        try self.parseNonterminal(205, false, true);
                    },
                    207 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    208 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    209 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    210 => {
                        if (self.chars.len >= self.start + 1 + self.acc and
                            std.mem.eql(u8, "|", self
                            .chars[self.start + self.acc .. self.start + self.acc + 1]))
                        {
                            self.acc += 1;
                        } else {
                            self.state = 214;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.parseNonterminal(248, false, true);
                    },
                    211 => {
                        try self.parseNonterminal(55, false, true);
                    },
                    212 => {
                        try self.parseNonterminal(210, false, true);
                    },
                    213 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    214 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    215 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    216 => {
                        switch (self.chars[self.acc + self.start]) {
                            '0'...'9',
                            => {
                                self.state = 217;
                                self.acc += 1;
                            },
                            '\x00'...'/',
                            ':'...'\xff',
                            => {
                                self.state = 219;
                                self.acc = 0;
                                self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                                continue;
                            },
                        }
                    },
                    217 => {
                        try self.parseNonterminal(216, false, true);
                    },
                    218 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    219 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    220 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    221 => {
                        switch (self.chars[self.acc + self.start]) {
                            '0'...'9',
                            => {
                                self.state = 222;
                                self.acc += 1;
                            },
                            '\x00'...'/',
                            ':'...'\xff',
                            => {
                                self.state = 224;
                                self.acc = 0;
                                self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                                continue;
                            },
                        }
                    },
                    222 => {
                        try self.parseNonterminal(221, false, true);
                    },
                    223 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    224 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    225 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    226 => {
                        try self.parseNonterminal(138, false, true);
                    },
                    227 => {
                        try self.parseNonterminal(226, false, true);
                    },
                    228 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    229 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    230 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    231 => {
                        switch (self.chars[self.acc + self.start]) {
                            '\x00'...'!',
                            '#'...'\xff',
                            => {
                                self.state = 232;
                            },
                            '\"',
                            => {
                                self.state = 235;
                                self.acc = 0;
                                self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                                continue;
                            },
                        }
                    },
                    232 => {
                        try self.parseNonterminal(165, false, true);
                    },
                    233 => {
                        try self.parseNonterminal(231, false, true);
                    },
                    234 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    235 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    236 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    237 => {
                        switch (self.chars[self.acc + self.start]) {
                            '\x00'...'&',
                            '('...'\xff',
                            => {
                                self.state = 238;
                            },
                            '\'',
                            => {
                                self.state = 241;
                                self.acc = 0;
                                self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                                continue;
                            },
                        }
                    },
                    238 => {
                        try self.parseNonterminal(165, false, true);
                    },
                    239 => {
                        try self.parseNonterminal(237, false, true);
                    },
                    240 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    241 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    242 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    243 => {
                        if (self.chars.len >= self.start + 1 + self.acc and
                            !std.mem.eql(u8, "]", self
                            .chars[self.start + self.acc .. self.start + self.acc + 1]))
                        {} else {
                            self.state = 246;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.parseNonterminal(154, false, true);
                    },
                    244 => {
                        try self.parseNonterminal(243, false, true);
                    },
                    245 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    246 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    247 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    248 => {
                        try self.parseNonterminal(179, false, true);
                    },
                    249 => {
                        try self.parseNonterminal(248, false, true);
                    },
                    250 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    251 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    252 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    253 => {
                        try self.parseNonterminal(189, true, false);
                    },
                    254 => {
                        switch (self.chars[self.acc + self.start]) {
                            '\x01'...'\xff',
                            => {
                                self.state = 255;
                                self.acc += 1;
                            },
                            '\x00',
                            => {
                                self.state = 257;
                                self.acc = 0;
                                self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                                continue;
                            },
                        }
                    },
                    255 => {
                        try self.parseNonterminal(253, false, true);
                    },
                    256 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    257 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    258 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    259 => {
                        try self.parseNonterminal(189, true, false);
                    },
                    260 => {
                        switch (self.chars[self.acc + self.start]) {
                            '\x01'...'\xff',
                            => {
                                self.state = 261;
                                self.acc += 1;
                            },
                            '\x00',
                            => {
                                self.state = 263;
                                self.acc = 0;
                                self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                                continue;
                            },
                        }
                    },
                    261 => {
                        try self.parseNonterminal(259, false, true);
                    },
                    262 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    263 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    264 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    265 => {
                        try self.parseNonterminal(37, false, true);
                    },
                    266 => {
                        try self.parseNonterminal(265, false, true);
                    },
                    267 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    268 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    269 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    270 => {
                        try self.parseNonterminal(96, false, true);
                    },
                    271 => {
                        try self.parseNonterminal(270, false, true);
                    },
                    272 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    273 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    274 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    275 => {
                        if (self.chars.len >= self.start + 6 + self.acc and
                            std.mem.eql(u8, "%% TOP", self
                            .chars[self.start + self.acc .. self.start + self.acc + 6]))
                        {
                            self.acc += 6;
                        } else {
                            self.state = 282;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.parseNonterminal(189, false, true);
                    },
                    276 => {
                        try self.parseNonterminal(248, false, true);
                    },
                    277 => {
                        try self.parseNonterminal(28, false, true);
                    },
                    278 => {
                        if (self.chars.len >= self.start + 2 + self.acc and
                            std.mem.eql(u8, "%%", self
                            .chars[self.start + self.acc .. self.start + self.acc + 2]))
                        {
                            self.acc += 2;
                        } else {
                            self.state = 282;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.parseNonterminal(189, false, true);
                    },
                    279 => {
                        try self.parseNonterminal(248, false, true);
                    },
                    280 => {
                        try self.parseNonterminal(248, false, true);
                    },
                    281 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    282 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    283 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    284 => {
                        if (self.chars.len >= self.start + 9 + self.acc and
                            std.mem.eql(u8, "%% FIELDS", self
                            .chars[self.start + self.acc .. self.start + self.acc + 9]))
                        {
                            self.acc += 9;
                        } else {
                            self.state = 291;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.parseNonterminal(189, false, true);
                    },
                    285 => {
                        try self.parseNonterminal(248, false, true);
                    },
                    286 => {
                        try self.parseNonterminal(28, false, true);
                    },
                    287 => {
                        if (self.chars.len >= self.start + 2 + self.acc and
                            std.mem.eql(u8, "%%", self
                            .chars[self.start + self.acc .. self.start + self.acc + 2]))
                        {
                            self.acc += 2;
                        } else {
                            self.state = 291;
                            self.acc = 0;
                            self.infer_actions.shrinkRetainingCapacity(self.stack_start);
                            continue;
                        }
                        try self.parseNonterminal(189, false, true);
                    },
                    288 => {
                        try self.parseNonterminal(248, false, true);
                    },
                    289 => {
                        try self.parseNonterminal(248, false, true);
                    },
                    290 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    291 => {
                        try self.returnFromNonterminal(false, false);
                    },
                    292 => {
                        try self.returnFromNonterminal(true, false);
                    },
                    else => unreachable,
                }
            }

            return if (!self.fail) blk: {
                const infer_result = self.infer() catch |err|
                    if (err == error.OutOfMemory)
                    return error.OutOfMemory
                else
                    ParseReturn{
                        .infer_fail = .{ .err = err, .msg = "action execution error" },
                    };
                break :blk infer_result;
            } else .{ .parse_fail = self.getParseError() };
        }
        fn finalizeInferInstrs(self: *@This()) Allocator.Error!void {
            for (self.infer_actions.items) |frame| {
                if (!opts.use_memo or !frame.memo) {
                    try self.infer_instrs.append(frame);
                } else {
                    try self.memoInfer(frame.state, frame.start);
                }
            }
            self.infer_actions.clearRetainingCapacity();
            self.stack_start = 0;
        }

        fn fail(self: @This(), msg: []const u8, err: ?anyerror) void {
            self.fail = true;
            self.infer_fail_err = err;
            self.infer_fail_msg = msg;
        }

        fn inferNonterminal(self: *@This(), comptime state: usize) Allocator.Error!void {
            try self.infer_stack.append(.{
                .acc = self.infer_acc,
                .state = self.infer_state,
            });

            const memo =
                self.memo.items[self.infer_acc - self.memo_start][
                AddrToRule[state]
            ];
            self.infer_state = ActionTranslate[memo.state];
        }

        fn returnFromInfer(self: *@This(), comptime state: usize) Allocator.Error!void {
            const frame = self.infer_stack.popOrNull() orelse blk: {
                self.infer_done = true;
                break :blk InferFrame{
                    .state = self.infer_state,
                    .acc = 0,
                };
            };

            try self.infer_instrs.append(.{
                .memo = false,
                .start = frame.acc,
                .state = state,
                .length = self.infer_acc - frame.acc,
            });
            self.infer_state = frame.state + 1;
        }
        fn callAction(self: *@This(), state: usize, start: usize, length: usize) !void {
            _ = start + length + self.state; // just to be able to compile

            switch (state) {
                9 => {
                    const @"$10" = self.calc_stack.pop().type_16;
                    const @"$1" = self.calc_stack.pop().type_27;
                    var @"$*1" = @"$1";
                    const @"$9": []const u8 = @"$10";
                    self.ir.name = @"$9";
                    self.ir.top_level_comment = invert([]const u8, try @"$*1".toOwnedSlice());
                },
                23 => {
                    const @"$3" = self.calc_stack.pop().type_2;
                    const @"$16" = self.calc_stack.pop().type_2;

                    self.ir.top_header = @"$16";

                    self.ir.field_header = @"$3";
                },
                26 => {},
                29 => {
                    const @"$ret": []const u8 = self.chars[start .. start + length];
                    try self.calc_stack.append(.{ .type_2 = @"$ret" });
                },
                33 => {},
                35 => {
                    const @"$0" = self.calc_stack.pop().type_18;
                    self.allocator.free(@"$0");
                },
                44 => {
                    const @"$4" = self.calc_stack.pop().type_29;
                    const @"$3" = self.calc_stack.pop().type_6;
                    const @"$1" = self.calc_stack.pop().type_5;
                    const @"$12" = self.calc_stack.pop().type_16;
                    const @"$0": []const u8 = @"$12";

                    _ = self.chars[start .. start + length]; // to prevent inlining
                    var sequences = @"$4";
                    try sequences.append(@"$3");
                    const def_cnt = self.ir.defs.items.len;
                    try self.ir.defs.append(.{
                        .id = def_cnt,
                        .identifier = @"$0",
                        .return_type = @"$1",
                        .sequences = sequences,
                        .accepts_eps = false,
                        .mid_recurse = false,
                        .right_recurse = false,
                        .regular = true,
                        .finite = true,
                    });
                },
                49 => {
                    const @"$2" = self.calc_stack.pop().type_16;
                    const @"$1": []const u8 = @"$2";
                    const @"$ret": ReturnType = ReturnType.init(@"$1", false, false);
                    try self.calc_stack.append(.{ .type_5 = @"$ret" });
                },
                52 => {
                    const @"$1" = self.calc_stack.pop().type_18;
                    const @"$ret": ReturnType = ReturnType.init(@"$1", true, false);
                    try self.calc_stack.append(.{ .type_5 = @"$ret" });
                },
                53 => {
                    const @"$ret": ReturnType = ReturnType.empty();
                    try self.calc_stack.append(.{ .type_5 = @"$ret" });
                },
                58 => {
                    const @"$2" = self.calc_stack.pop().type_8;
                    const @"$0" = self.calc_stack.pop().type_7;
                    const @"$ret": Sequence =
                        blk: {
                        var seq = @"$0";
                        seq.action = @"$2";
                        break :blk seq;
                    };
                    try self.calc_stack.append(.{ .type_6 = @"$ret" });
                },
                60 => {
                    const @"$0" = self.calc_stack.pop().type_7;
                    const @"$ret": Sequence = @"$0";
                    try self.calc_stack.append(.{ .type_6 = @"$ret" });
                },
                64 => {
                    const @"$2" = self.calc_stack.pop().type_40;
                    var @"$*2" = @"$2";
                    const @"$1" = self.calc_stack.pop().type_12;
                    const @"$0": std.ArrayList(Operated) = blk: {
                        try @"$*2".append(@"$1");
                        break :blk @"$*2";
                    };
                    const @"$ret": Sequence = .{
                        .operateds = @"$0",
                        .string = self.chars[start .. start + length],
                        .action = Action.empty(self.ir.allocator),
                    };
                    try self.calc_stack.append(.{ .type_7 = @"$ret" });
                },
                67 => {
                    const @"$0" = self.calc_stack.pop().type_9;
                    const @"$ret": Action = .{
                        .implicit = false,
                        .bases = blk: {
                            var bases = std.ArrayList(ir.ActionBase).init(self.ir.allocator);
                            try bases.append(.{
                                .data = self.chars[start .. start + length],
                                .owned = false,
                                .action_vars = @"$0",
                                .return_type = ReturnType.impl(),
                                .id = 0,
                                .mut = false,
                            });
                            break :blk bases;
                        },
                        .use_match = blk: {
                            for (@"$0".items) |item| {
                                if (!item.isMatchedString()) continue;
                                break :blk true;
                            }
                            break :blk false;
                        },
                        .rets = std.ArrayList(ActionReturn)
                            .init(self.ir.allocator),
                    };
                    try self.calc_stack.append(.{ .type_8 = @"$ret" });
                },
                72 => {
                    const @"$4" = self.calc_stack.pop().type_9;
                    const @"$2" = self.calc_stack.pop().type_9;
                    const @"$0" = self.calc_stack.pop().type_10;
                    const @"$ret": std.ArrayList(ActionVar) =
                        blk: {
                        var list = @"$4";
                        try list.appendSlice(@"$0".items);
                        try list.appendSlice(@"$2".items);
                        @"$0".deinit();
                        @"$2".deinit();
                        break :blk list;
                    };
                    try self.calc_stack.append(.{ .type_9 = @"$ret" });
                },
                74 => {
                    const @"$0" = self.calc_stack.pop().type_10;
                    const @"$ret": std.ArrayList(ActionVar) = @"$0";
                    try self.calc_stack.append(.{ .type_9 = @"$ret" });
                },
                75 => {
                    const @"$ret": std.ArrayList(ActionVar) = std.ArrayList(ActionVar).init(self.ir.allocator);
                    try self.calc_stack.append(.{ .type_9 = @"$ret" });
                },
                79 => {
                    const @"$1" = self.calc_stack.pop().type_10;
                    const @"$0" = self.calc_stack.pop().type_11;
                    const @"$ret": std.ArrayList(ActionVar) =
                        blk: {
                        var l = @"$1";
                        try l.append(@"$0");
                        break :blk l;
                    };
                    try self.calc_stack.append(.{ .type_10 = @"$ret" });
                },
                83 => {
                    const @"$2" = self.calc_stack.pop().type_10;
                    const @"$ret": std.ArrayList(ActionVar) = @"$2";
                    try self.calc_stack.append(.{ .type_10 = @"$ret" });
                },
                86 => {
                    const @"$1" = self.calc_stack.pop().type_10;
                    const @"$0" = self.calc_stack.pop().type_18;
                    const @"$ret": std.ArrayList(ActionVar) =
                        blk: {
                        self.allocator.free(@"$0");
                        break :blk @"$1";
                    };
                    try self.calc_stack.append(.{ .type_10 = @"$ret" });
                },
                87 => {
                    const @"$ret": std.ArrayList(ActionVar) = std.ArrayList(ActionVar).init(self.ir.allocator);
                    try self.calc_stack.append(.{ .type_10 = @"$ret" });
                },
                91 => {
                    const @"$ret": ActionVar =
                        blk: {
                        const num = std.fmt.parseInt(usize, self.chars[start .. start + length][1..], 10) catch |err| switch (err) {
                            error.InvalidCharacter => unreachable,
                            else => {
                                std.debug.print("too large integer: {d}\n", .{self.chars[start .. start + length][1..]});
                                self.fail = true;
                                self.infer_done = true;
                                return;
                            },
                        };
                        break :blk .{
                            .var_decl = self.chars[start .. start + length],
                            .arg_num = if (num == 0) null else num - 1,
                            .escape = false,
                        };
                    };
                    try self.calc_stack.append(.{ .type_11 = @"$ret" });
                },
                94 => {
                    const @"$ret": ActionVar =
                        blk: {
                        const num = std.fmt.parseInt(usize, self.chars[start .. start + length][2..], 10) catch |err| switch (err) {
                            error.InvalidCharacter => unreachable,
                            else => {
                                std.debug.print("too large integer: {d}\n", .{self.chars[start .. start + length][2..]});
                                self.fail = true;
                                self.infer_done = true;
                                return;
                            },
                        };
                        break :blk .{
                            .var_decl = self.chars[start .. start + length],
                            .arg_num = num - 1,
                            .escape = true, // because it is mutable
                        };
                    };
                    try self.calc_stack.append(.{ .type_11 = @"$ret" });
                },
                99 => {
                    const @"$2" = self.calc_stack.pop().type_14;
                    const @"$1" = self.calc_stack.pop().type_15;
                    const @"$0" = self.calc_stack.pop().type_13;
                    const @"$ret": Operated = .{
                        .prefix_op = @"$0",
                        .postfix_op = @"$2",
                        .value = @"$1",
                        .return_type = switch (@"$1") {
                            .IDENTIFIER,
                            .SEQ,
                            => ReturnType.impl(),
                            else => ReturnType.empty(),
                        },
                        .string = std.mem.trimRight(u8, self.chars[start .. start + length], " \t\n\r"),
                    };
                    try self.calc_stack.append(.{ .type_12 = @"$ret" });
                },
                102 => {
                    const @"$ret": PrefixOp = .AND;
                    try self.calc_stack.append(.{ .type_13 = @"$ret" });
                },
                104 => {
                    const @"$ret": PrefixOp = .NOT;
                    try self.calc_stack.append(.{ .type_13 = @"$ret" });
                },
                105 => {
                    const @"$ret": PrefixOp = .NONE;
                    try self.calc_stack.append(.{ .type_13 = @"$ret" });
                },
                108 => {
                    const @"$ret": PostfixOp = .STAR;
                    try self.calc_stack.append(.{ .type_14 = @"$ret" });
                },
                110 => {
                    const @"$ret": PostfixOp = .PLUS;
                    try self.calc_stack.append(.{ .type_14 = @"$ret" });
                },
                112 => {
                    const @"$ret": PostfixOp = .QUESTION;
                    try self.calc_stack.append(.{ .type_14 = @"$ret" });
                },
                113 => {
                    const @"$ret": PostfixOp = .NONE;
                    try self.calc_stack.append(.{ .type_14 = @"$ret" });
                },
                118 => {
                    const @"$1" = self.calc_stack.pop().type_7;
                    const @"$ret": Primary = .{ .SEQ = @"$1" };
                    try self.calc_stack.append(.{ .type_15 = @"$ret" });
                },
                121 => {
                    const @"$1" = self.calc_stack.pop().type_16;
                    const @"$0": []const u8 = @"$1";
                    const @"$ret": Primary = .{ .IDENTIFIER = @"$0" };
                    try self.calc_stack.append(.{ .type_15 = @"$ret" });
                },
                123 => {
                    const @"$0" = self.calc_stack.pop().type_18;
                    const @"$ret": Primary = .{ .LITERAL = @"$0" };
                    try self.calc_stack.append(.{ .type_15 = @"$ret" });
                },
                126 => {
                    const @"$2" = self.calc_stack.pop().type_35;
                    const @"$0": Class = .{ .content = @"$2" };
                    const @"$ret": Primary = .{ .CLASS = @"$0" };
                    try self.calc_stack.append(.{ .type_15 = @"$ret" });
                },
                128 => {
                    const @"$ret": Primary = .DOT;
                    try self.calc_stack.append(.{ .type_15 = @"$ret" });
                },
                130 => {
                    const @"$ret": Primary = .EPSILON;
                    try self.calc_stack.append(.{ .type_15 = @"$ret" });
                },
                132 => {
                    const @"$ret": Primary = .CUT;
                    try self.calc_stack.append(.{ .type_15 = @"$ret" });
                },
                136 => {
                    const @"$ret": []const u8 = self.chars[start .. start + length];
                    try self.calc_stack.append(.{ .type_16 = @"$ret" });
                },
                139 => {},
                141 => {},
                147 => {
                    const @"$1" = self.calc_stack.pop().type_34;
                    var @"$*1" = @"$1";
                    const @"$ret": []const u8 = invert(u8, try @"$*1".toOwnedSlice());
                    try self.calc_stack.append(.{ .type_18 = @"$ret" });
                },
                152 => {
                    const @"$1" = self.calc_stack.pop().type_33;
                    var @"$*1" = @"$1";
                    const @"$ret": []const u8 = invert(u8, try @"$*1".toOwnedSlice());
                    try self.calc_stack.append(.{ .type_18 = @"$ret" });
                },
                156 => {
                    const @"$2" = self.calc_stack.pop().type_20;
                    const @"$0" = self.calc_stack.pop().type_20;
                    const @"$ret": Range = .{
                        .from = @"$0",
                        .to = @"$2",
                        .backing = self.chars[start .. start + length],
                    };
                    try self.calc_stack.append(.{ .type_19 = @"$ret" });
                },
                158 => {
                    const @"$0" = self.calc_stack.pop().type_20;
                    const @"$ret": Range = .{
                        .from = @"$0",
                        .to = 0,
                        .backing = self.chars[start .. start + length],
                    };
                    try self.calc_stack.append(.{ .type_19 = @"$ret" });
                },
                161 => {
                    const @"$ret": u8 = '-';
                    try self.calc_stack.append(.{ .type_20 = @"$ret" });
                },
                163 => {
                    const @"$1" = self.calc_stack.pop().type_21;
                    const @"$ret": u8 = @"$1";
                    try self.calc_stack.append(.{ .type_20 = @"$ret" });
                },
                166 => {
                    const @"$ret": u8 =
                        switch (self.chars[start .. start + length][1]) {
                        'n' => '\n',
                        'r' => '\r',
                        't' => '\t',
                        else => |c| c,
                    };
                    try self.calc_stack.append(.{ .type_21 = @"$ret" });
                },
                169 => {
                    const @"$ret": u8 = try std.fmt.parseInt(u8, self.chars[start .. start + length][2..], 16);
                    try self.calc_stack.append(.{ .type_21 = @"$ret" });
                },
                171 => {
                    const @"$ret": u8 = try std.fmt.parseInt(u8, self.chars[start .. start + length][2..], 16);
                    try self.calc_stack.append(.{ .type_21 = @"$ret" });
                },
                173 => {
                    const @"$ret": u8 = self.chars[start .. start + length][0];
                    try self.calc_stack.append(.{ .type_21 = @"$ret" });
                },
                177 => {},
                180 => {},
                184 => {},
                187 => {
                    const @"$ret": []const u8 = self.chars[start .. start + length];
                    try self.calc_stack.append(.{ .type_24 = @"$ret" });
                },
                189 => {},
                190 => {},
                191 => {},
                193 => {},
                194 => {},
                196 => {},
                202 => {
                    const @"$1" = self.calc_stack.pop().type_27;
                    var @"$*1" = @"$1";
                    const @"$6" = self.calc_stack.pop().type_24;
                    const @"$2": []const u8 = @"$6";
                    const @"$0": []const u8 = @"$2";
                    const @"$ret": std.ArrayList([]const u8) = blk: {
                        try @"$*1".append(@"$0");
                        break :blk @"$*1";
                    };
                    try self.calc_stack.append(.{ .type_27 = @"$ret" });
                },
                203 => {
                    const @"$ret": std.ArrayList([]const u8) = std.ArrayList([]const u8).init(self.allocator);
                    try self.calc_stack.append(.{ .type_27 = @"$ret" });
                },
                207 => {},
                208 => {},
                213 => {
                    const @"$1" = self.calc_stack.pop().type_29;
                    var @"$*1" = @"$1";
                    const @"$3" = self.calc_stack.pop().type_6;
                    const @"$0": Sequence = @"$3";
                    const @"$ret": std.ArrayList(Sequence) = blk: {
                        try @"$*1".append(@"$0");
                        break :blk @"$*1";
                    };
                    try self.calc_stack.append(.{ .type_29 = @"$ret" });
                },
                214 => {
                    const @"$ret": std.ArrayList(Sequence) = std.ArrayList(Sequence).init(self.allocator);
                    try self.calc_stack.append(.{ .type_29 = @"$ret" });
                },
                218 => {},
                219 => {},
                223 => {},
                224 => {},
                228 => {},
                229 => {},
                234 => {
                    const @"$1" = self.calc_stack.pop().type_33;
                    var @"$*1" = @"$1";
                    const @"$3" = self.calc_stack.pop().type_21;
                    const @"$0": u8 = @"$3";
                    const @"$ret": std.ArrayList(u8) = blk: {
                        try @"$*1".append(@"$0");
                        break :blk @"$*1";
                    };
                    try self.calc_stack.append(.{ .type_33 = @"$ret" });
                },
                235 => {
                    const @"$ret": std.ArrayList(u8) = std.ArrayList(u8).init(self.allocator);
                    try self.calc_stack.append(.{ .type_33 = @"$ret" });
                },
                240 => {
                    const @"$1" = self.calc_stack.pop().type_34;
                    var @"$*1" = @"$1";
                    const @"$3" = self.calc_stack.pop().type_21;
                    const @"$0": u8 = @"$3";
                    const @"$ret": std.ArrayList(u8) = blk: {
                        try @"$*1".append(@"$0");
                        break :blk @"$*1";
                    };
                    try self.calc_stack.append(.{ .type_34 = @"$ret" });
                },
                241 => {
                    const @"$ret": std.ArrayList(u8) = std.ArrayList(u8).init(self.allocator);
                    try self.calc_stack.append(.{ .type_34 = @"$ret" });
                },
                245 => {
                    const @"$1" = self.calc_stack.pop().type_35;
                    var @"$*1" = @"$1";
                    const @"$3" = self.calc_stack.pop().type_19;
                    const @"$0": Range = @"$3";
                    const @"$ret": std.ArrayList(Range) = blk: {
                        try @"$*1".append(@"$0");
                        break :blk @"$*1";
                    };
                    try self.calc_stack.append(.{ .type_35 = @"$ret" });
                },
                246 => {
                    const @"$ret": std.ArrayList(Range) = std.ArrayList(Range).init(self.allocator);
                    try self.calc_stack.append(.{ .type_35 = @"$ret" });
                },
                250 => {},
                251 => {},
                256 => {},
                257 => {},
                262 => {},
                263 => {},
                267 => {},
                268 => {},
                272 => {
                    const @"$1" = self.calc_stack.pop().type_40;
                    var @"$*1" = @"$1";
                    const @"$0" = self.calc_stack.pop().type_12;
                    const @"$ret": std.ArrayList(Operated) = blk: {
                        try @"$*1".append(@"$0");
                        break :blk @"$*1";
                    };
                    try self.calc_stack.append(.{ .type_40 = @"$ret" });
                },
                273 => {
                    const @"$ret": std.ArrayList(Operated) = std.ArrayList(Operated).init(self.allocator);
                    try self.calc_stack.append(.{ .type_40 = @"$ret" });
                },
                281 => {
                    const @"$2" = self.calc_stack.pop().type_2;

                    self.ir.top_header = @"$2";
                },
                282 => {},
                290 => {
                    const @"$2" = self.calc_stack.pop().type_2;

                    self.ir.field_header = @"$2";
                },
                291 => {},
                else => unreachable,
            }
            return;
        }
        fn memoInfer(self: *@This(), state: usize, start: usize) Allocator.Error!void {
            self.infer_acc = start;
            self.infer_state = ActionTranslate[state];
            self.infer_done = false;

            while (!self.infer_done) {
                switch (self.infer_state) {
                    0 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(248);
                    },
                    1 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(198);
                    },
                    2 => {
                        self.infer_acc += 7;
                        try self.inferNonterminal(248);
                    },
                    3 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(134);
                    },
                    4 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(248);
                    },
                    5 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(11);
                    },
                    6 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(37);
                    },
                    7 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(265);
                    },
                    8 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(9);
                    },
                    9 => {
                        self.infer_acc += 6;
                        try self.inferNonterminal(189);
                    },
                    10 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(248);
                    },
                    11 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(28);
                    },
                    12 => {
                        self.infer_acc += 2;
                        try self.inferNonterminal(189);
                    },
                    13 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(248);
                    },
                    14 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(248);
                    },
                    15 => {
                        self.infer_acc += 9;
                        try self.inferNonterminal(189);
                    },
                    16 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(248);
                    },
                    17 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(28);
                    },
                    18 => {
                        self.infer_acc += 2;
                        try self.inferNonterminal(189);
                    },
                    19 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(248);
                    },
                    20 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(248);
                    },
                    21 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(23);
                    },
                    22 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(284);
                    },
                    23 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(275);
                    },
                    24 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(26);
                    },
                    25 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(205);
                    },
                    26 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(29);
                    },
                    27 => {
                        self.infer_acc += 1;
                        try self.returnFromInfer(33);
                    },
                    28 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(143);
                    },
                    29 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(35);
                    },
                    30 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(134);
                    },
                    31 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(248);
                    },
                    32 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(46);
                    },
                    33 => {
                        self.infer_acc += 1;
                        try self.inferNonterminal(248);
                    },
                    34 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(55);
                    },
                    35 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(210);
                    },
                    36 => {
                        self.infer_acc += 1;
                        try self.inferNonterminal(248);
                    },
                    37 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(44);
                    },
                    38 => {
                        self.infer_acc += 1;
                        try self.inferNonterminal(248);
                    },
                    39 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(134);
                    },
                    40 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(248);
                    },
                    41 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(49);
                    },
                    42 => {
                        self.infer_acc += 1;
                        try self.inferNonterminal(248);
                    },
                    43 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(143);
                    },
                    44 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(52);
                    },
                    45 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(53);
                    },
                    46 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(62);
                    },
                    47 => {
                        self.infer_acc += 1;
                        try self.inferNonterminal(66);
                    },
                    48 => {
                        self.infer_acc += 1;
                        try self.inferNonterminal(248);
                    },
                    49 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(58);
                    },
                    50 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(62);
                    },
                    51 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(60);
                    },
                    52 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(96);
                    },
                    53 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(270);
                    },
                    54 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(64);
                    },
                    55 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(69);
                    },
                    56 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(67);
                    },
                    57 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(77);
                    },
                    58 => {
                        self.infer_acc += 1;
                        try self.inferNonterminal(69);
                    },
                    59 => {
                        self.infer_acc += 1;
                        try self.inferNonterminal(69);
                    },
                    60 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(72);
                    },
                    61 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(77);
                    },
                    62 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(74);
                    },
                    63 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(75);
                    },
                    64 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(89);
                    },
                    65 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(77);
                    },
                    66 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(79);
                    },
                    67 => {
                        self.infer_acc += 1;
                        try self.inferNonterminal(77);
                    },
                    68 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(83);
                    },
                    69 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(143);
                    },
                    70 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(77);
                    },
                    71 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(86);
                    },
                    72 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(87);
                    },
                    73 => {
                        self.infer_acc += 2;
                        try self.inferNonterminal(221);
                    },
                    74 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(91);
                    },
                    75 => {
                        self.infer_acc += 3;
                        try self.inferNonterminal(216);
                    },
                    76 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(94);
                    },
                    77 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(101);
                    },
                    78 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(115);
                    },
                    79 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(107);
                    },
                    80 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(99);
                    },
                    81 => {
                        self.infer_acc += 1;
                        try self.inferNonterminal(248);
                    },
                    82 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(102);
                    },
                    83 => {
                        self.infer_acc += 1;
                        try self.inferNonterminal(248);
                    },
                    84 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(104);
                    },
                    85 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(105);
                    },
                    86 => {
                        self.infer_acc += 1;
                        try self.inferNonterminal(248);
                    },
                    87 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(108);
                    },
                    88 => {
                        self.infer_acc += 1;
                        try self.inferNonterminal(248);
                    },
                    89 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(110);
                    },
                    90 => {
                        self.infer_acc += 1;
                        try self.inferNonterminal(248);
                    },
                    91 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(112);
                    },
                    92 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(113);
                    },
                    93 => {
                        self.infer_acc += 1;
                        try self.inferNonterminal(248);
                    },
                    94 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(62);
                    },
                    95 => {
                        self.infer_acc += 1;
                        try self.inferNonterminal(248);
                    },
                    96 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(118);
                    },
                    97 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(134);
                    },
                    98 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(248);
                    },
                    99 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(121);
                    },
                    100 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(143);
                    },
                    101 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(123);
                    },
                    102 => {
                        self.infer_acc += 1;
                        try self.inferNonterminal(243);
                    },
                    103 => {
                        self.infer_acc += 1;
                        try self.inferNonterminal(248);
                    },
                    104 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(126);
                    },
                    105 => {
                        self.infer_acc += 1;
                        try self.inferNonterminal(248);
                    },
                    106 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(128);
                    },
                    107 => {
                        self.infer_acc += 1;
                        try self.inferNonterminal(248);
                    },
                    108 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(130);
                    },
                    109 => {
                        self.infer_acc += 1;
                        try self.inferNonterminal(248);
                    },
                    110 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(132);
                    },
                    111 => {
                        self.infer_acc += 1;
                        try self.inferNonterminal(226);
                    },
                    112 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(136);
                    },
                    113 => {
                        self.infer_acc += 1;
                        try self.returnFromInfer(139);
                    },
                    114 => {
                        self.infer_acc += 1;
                        try self.returnFromInfer(141);
                    },
                    115 => {
                        self.infer_acc += 1;
                        try self.inferNonterminal(237);
                    },
                    116 => {
                        self.infer_acc += 1;
                        try self.inferNonterminal(248);
                    },
                    117 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(147);
                    },
                    118 => {
                        self.infer_acc += 1;
                        try self.inferNonterminal(231);
                    },
                    119 => {
                        self.infer_acc += 1;
                        try self.inferNonterminal(248);
                    },
                    120 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(152);
                    },
                    121 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(160);
                    },
                    122 => {
                        self.infer_acc += 1;
                        try self.inferNonterminal(160);
                    },
                    123 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(156);
                    },
                    124 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(160);
                    },
                    125 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(158);
                    },
                    126 => {
                        self.infer_acc += 2;
                        try self.returnFromInfer(161);
                    },
                    127 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(165);
                    },
                    128 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(163);
                    },
                    129 => {
                        self.infer_acc += 2;
                        try self.returnFromInfer(166);
                    },
                    130 => {
                        self.infer_acc += 4;
                        try self.returnFromInfer(169);
                    },
                    131 => {
                        self.infer_acc += 4;
                        try self.returnFromInfer(171);
                    },
                    132 => {
                        self.infer_acc += 1;
                        try self.returnFromInfer(173);
                    },
                    133 => {
                        self.infer_acc += 2;
                        try self.inferNonterminal(189);
                    },
                    134 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(248);
                    },
                    135 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(177);
                    },
                    136 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(193);
                    },
                    137 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(180);
                    },
                    138 => {
                        self.infer_acc += 2;
                        try self.inferNonterminal(253);
                    },
                    139 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(189);
                    },
                    140 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(184);
                    },
                    141 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(259);
                    },
                    142 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(187);
                    },
                    143 => {
                        self.infer_acc += 2;
                        try self.returnFromInfer(189);
                    },
                    144 => {
                        self.infer_acc += 1;
                        try self.returnFromInfer(190);
                    },
                    145 => {
                        self.infer_acc += 1;
                        try self.returnFromInfer(191);
                    },
                    146 => {
                        self.infer_acc += 1;
                        try self.returnFromInfer(193);
                    },
                    147 => {
                        self.infer_acc += 1;
                        try self.returnFromInfer(194);
                    },
                    148 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(189);
                    },
                    149 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(196);
                    },
                    150 => {
                        self.infer_acc += 3;
                        try self.inferNonterminal(186);
                    },
                    151 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(189);
                    },
                    152 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(248);
                    },
                    153 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(198);
                    },
                    154 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(202);
                    },
                    155 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(203);
                    },
                    156 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(31);
                    },
                    157 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(205);
                    },
                    158 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(207);
                    },
                    159 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(208);
                    },
                    160 => {
                        self.infer_acc += 1;
                        try self.inferNonterminal(248);
                    },
                    161 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(55);
                    },
                    162 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(210);
                    },
                    163 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(213);
                    },
                    164 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(214);
                    },
                    165 => {
                        self.infer_acc += 1;
                        try self.inferNonterminal(216);
                    },
                    166 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(218);
                    },
                    167 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(219);
                    },
                    168 => {
                        self.infer_acc += 1;
                        try self.inferNonterminal(221);
                    },
                    169 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(223);
                    },
                    170 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(224);
                    },
                    171 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(138);
                    },
                    172 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(226);
                    },
                    173 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(228);
                    },
                    174 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(229);
                    },
                    175 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(165);
                    },
                    176 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(231);
                    },
                    177 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(234);
                    },
                    178 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(235);
                    },
                    179 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(165);
                    },
                    180 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(237);
                    },
                    181 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(240);
                    },
                    182 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(241);
                    },
                    183 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(154);
                    },
                    184 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(243);
                    },
                    185 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(245);
                    },
                    186 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(246);
                    },
                    187 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(179);
                    },
                    188 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(248);
                    },
                    189 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(250);
                    },
                    190 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(251);
                    },
                    191 => {
                        self.infer_acc += 1;
                        try self.inferNonterminal(253);
                    },
                    192 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(256);
                    },
                    193 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(257);
                    },
                    194 => {
                        self.infer_acc += 1;
                        try self.inferNonterminal(259);
                    },
                    195 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(262);
                    },
                    196 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(263);
                    },
                    197 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(37);
                    },
                    198 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(265);
                    },
                    199 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(267);
                    },
                    200 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(268);
                    },
                    201 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(96);
                    },
                    202 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(270);
                    },
                    203 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(272);
                    },
                    204 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(273);
                    },
                    205 => {
                        self.infer_acc += 6;
                        try self.inferNonterminal(189);
                    },
                    206 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(248);
                    },
                    207 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(28);
                    },
                    208 => {
                        self.infer_acc += 2;
                        try self.inferNonterminal(189);
                    },
                    209 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(248);
                    },
                    210 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(248);
                    },
                    211 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(281);
                    },
                    212 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(282);
                    },
                    213 => {
                        self.infer_acc += 9;
                        try self.inferNonterminal(189);
                    },
                    214 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(248);
                    },
                    215 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(28);
                    },
                    216 => {
                        self.infer_acc += 2;
                        try self.inferNonterminal(189);
                    },
                    217 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(248);
                    },
                    218 => {
                        self.infer_acc += 0;
                        try self.inferNonterminal(248);
                    },
                    219 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(290);
                    },
                    220 => {
                        self.infer_acc += 0;
                        try self.returnFromInfer(291);
                    },
                    else => unreachable,
                }
            }
        }
        fn infer(self: *@This()) !ParseReturn {
            try self.finalizeInferInstrs();
            for (self.infer_instrs.items) |instr| {
                try self.callAction(instr.state, instr.start, instr.length);
            }

            const output: ParseReturn = if (self.fail)
                .{ .infer_fail = .{
                    .err = self.infer_fail_err,
                    .msg = self.infer_fail_msg,
                } }
            else
                .{ .pass = void{} };

            assert(self.fail or self.calc_stack.items.len == 0);
            return output;
        }
    };
}
