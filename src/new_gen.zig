// This file is part of Zapp, a packrat parser generator.
// Copyright (C) 2024  Daniel Gr√©vent
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <https://www.gnu.org/licenses/>.

const std = @import("std");
const assert = std.debug.assert;
const Allocator = std.mem.Allocator;
const Writer = std.fs.File.Writer;

const lir = @import("low_ir.zig");
const su = @import("string_utils.zig");
const pir = @import("peg_ir.zig");
const Version = @import("config").Version;
const skl = @import("runtime/skeleton.zig");

const CodeGen = @This();

writer: Writer,
ir: lir.LowIr,
parse_return: pir.ReturnType,

pub fn generate(
    self: *CodeGen,
    ir: lir.LowIr,
    writer: Writer,
) !void {
    self.writer = writer;
    self.ir = ir;
    try self.ir.compressBases();

    try writer.print(
        "// {s} parser generated by zapp {}. DO NOT EDIT!\n\n",
        .{ ir.parser_name, Version },
    );

    try self.genTopLevelComment();

    // imports
    try writer.print("{s}\n", .{skl.imports});
    try writer.print("\n{s}\n", .{self.ir.top_header});

    // type declarations
    try writer.writeAll(@embedFile("runtime/memo.zig"));
    try self.returnTypes();
    try self.parseReturn();
    try writer.print("{s}\n", .{skl.structs});

    // lookups
    try self.nameTable();
    try self.addrToRule();
    try self.addrToFailState();
    try self.actionTranslationTable();
    try self.addrToNFail();

    // fn start
    try writer.print(
        "pub fn @\"{s}\"(comptime opts: ParseOptions) type {{\n",
        .{ir.parser_name},
    );
    try writer.print("    return struct {{\n", .{});

    // fields
    try writer.print("{s}\n", .{skl.vars});
    try writer.print("\n{s}\n", .{self.ir.field_header});

    // static funcs
    try writer.print("{s}\n", .{skl.funcs});

    // generated funcs
    try self.resetMemo();
    try self.parse();

    if (self.ir.is_acceptor) {
        try writer.print("}};\n}}", .{});
        return;
    }

    // static infer funcs
    try writer.print("{s}\n", .{skl.inferFuncs});

    // generated infer funcs
    try self.callAction();
    try self.memoInfer();
    try self.infer();

    // fn end
    try writer.print("}};\n}}", .{});
}

/// adds the return type for the parse function
fn parseReturn(self: *CodeGen) !void {
    const writer = self.writer;
    try writer.print(skl.parse_return, .{self.parse_return});
}

fn genTopLevelComment(self: *CodeGen) !void {
    const writer = self.writer;
    for (self.ir.top_level_comment) |content| {
        try writer.print("//{s}\n", .{content});
    }
    if (self.ir.top_level_comment.len > 0) try writer.writeByte('\n');
}

fn resetMemo(self: *CodeGen) !void {
    const finalize = if (self.ir.is_acceptor)
        ""
    else
        "try self.finalizeInferInstrs();";
    try self.writer.print(skl.resetMemo, .{finalize});
}

/// lookup generation
/// for error messages
fn nameTable(self: *CodeGen) !void {
    const writer = self.writer;
    try writer.print("const NameTable = [_][]const u8{{\n", .{});

    for (self.ir.rule_names) |rule_name| {
        try su.writeString(writer, rule_name);
        try writer.print(",\n", .{});
    }

    try writer.print("}};\n", .{});
}

/// lookup generation for
/// finding the fail state an address would go to
fn addrToFailState(self: *CodeGen) !void {
    const blocks = self.ir.blocks.items;
    const writer = self.writer;

    try writer.print("const AddrToFailState = [_]State{{\n", .{});

    try writer.print("{d}", .{
        if (blocks[0].fail) |f| f.id else blocks.len,
    });

    for (blocks[1..]) |block| {
        try writer.print(", {d}", .{
            if (block.fail) |f| f.id else blocks.len,
        });
    }

    try writer.print("}};\n", .{});
}

/// lookup generation
fn addrToRule(self: *CodeGen) !void {
    const blocks = self.ir.blocks.items;
    try self.writer.print("const AddrToRule = [_]Rule{{\n", .{});

    const first = blocks[0].base;
    try self.writer.print("{d}", .{first});

    var max_rule: usize = 0;
    for (blocks[1..]) |block| {
        try self.writer.print(", {d}", .{block.base});
        max_rule = @max(max_rule, block.base);
    }

    try self.writer.print("}};\n", .{});
    try self.writer.print("const RuleCount = {d};\n", .{max_rule + 1});
}

fn addrToNFail(self: *CodeGen) !void {
    const blocks = self.ir.blocks.items;
    try self.writer.print("const AddrToNFail = [_]bool {{", .{});

    try self.writer.print("{}", .{blocks[0].meta.nonterm_fail});
    for (blocks[1..]) |block| {
        try self.writer.print(", {}", .{block.meta.nonterm_fail});
    }

    try self.writer.print("}};\n", .{});
}

fn actionTranslationTable(self: *CodeGen) !void {
    const blocks = self.ir.blocks.items;
    const allocator = self.ir.allocator;
    var table = try allocator.alloc(usize, blocks.len);
    defer allocator.free(table);
    @memset(table, 0);

    var count: usize = 0;
    // this works because the
    for (self.ir.actions.items) |action| {
        const add = action.base.id;
        table[add] = count + 1;
        count += action.nonterms.items.len + 1;
    }

    var last: usize = count;
    for (0..blocks.len) |i| {
        const idx = blocks.len - 1 - i;
        if (table[idx] == 0) {
            table[idx] = blocks.len + 1;
        } else {
            assert(last >= table[idx]);
            last = table[idx];
        }
    }

    try self.writer.print("const ActionTranslate = [_]State{{\n", .{});

    try self.writer.print("{d}", .{table[0] - 1});
    for (1..blocks.len) |i| {
        try self.writer.print(", {d}", .{table[i] - 1});
    }

    try self.writer.print("}};\n", .{});
}

fn returnTypes(self: *CodeGen) !void {
    const allocator = self.ir.allocator;
    const actions = self.ir.actions.items;
    const blocks = self.ir.blocks.items;
    var lookup = try allocator.alloc(bool, blocks.len);
    @memset(lookup, false);
    defer allocator.free(lookup);

    try self.writer.print("const InferReturnType = union {{\n", .{});

    for (actions) |action| {
        const def = action.base.base;
        if (lookup[def]) continue;
        lookup[def] = true;

        const bases = action.bases.items;
        if (bases.len >= 1) {
            const last_base = bases[0];
            if (!last_base.return_type.isNone()) {
                try self.writer.print("type_{d}: {s},\n", .{ def, last_base.return_type });
            }
            if (def == 0) self.parse_return = last_base.return_type;
        } else if (def == 0) {
            self.parse_return = pir.ReturnType.empty();
        }
    }
    try self.writer.print("}};\n", .{});
}

fn parse(self: *CodeGen) !void {
    try self.writer.print("{s}\n", .{skl.parseStart});
    for (self.ir.blocks.items) |blk| {
        try self.parseBlock(blk);
    }

    try self.writer.print("{s}\n", .{if (self.ir.is_acceptor)
        skl.parseEndAccept
    else
        skl.parseEnd});
}

fn parseBlock(self: *CodeGen, block: *lir.Block) !void {
    const writer = self.writer;
    try writer.print("{d} => {{\n", .{block.id});

    for (block.insts.items) |*instr| {
        try self.parseInstr(instr, block.fail);
    }

    try writer.print("}},\n", .{});
}

fn parseInstr(self: *CodeGen, instr: *lir.Instr, fail: ?*lir.Block) !void {
    const w = self.writer;
    switch (instr.tag) {
        .JMP => {
            try self.writer.print("self.state = {d};\n", .{instr.data.jmp.id});
        },
        .STRING => try self.parseString(instr, fail.?),
        .MATCH => try self.parseMatch(instr, fail.?),
        .NONTERM => try self.writer.print(
            "try self.parseNonterminal({d}, {}, {});\n",
            .{
                instr.data.ctx_jmp.next.id,
                instr.meta.neg,
                !instr.meta.pos and !instr.meta.neg,
            },
        ),
        .FAIL => try w.print("try self.returnFromNonterminal(true, false);\n", .{}),
        .RET => try w.print("try self.returnFromNonterminal(false, false);\n", .{}),
        .EXIT_FAIL => {
            try w.print("try self.returnFromNonterminal(true, false);\n", .{});
            try w.print("break;\n", .{});
        },
        .EXIT_PASS => {
            try w.print("try self.returnFromNonterminal(false, false);\n", .{});
            try w.print("break;\n", .{});
        },
    }
}

fn parseMatch(self: *CodeGen, instr: *lir.Instr, fail: *lir.Block) !void {
    const allocator = self.ir.allocator;
    const match = instr.data.match.items;
    try self.writer.print("switch (self.chars[self.acc + self.start]) {{\n", .{});

    var merged = try match[0].clone();
    defer merged.deinit();

    try self.parseProng(match[0], false);
    for (match[1..]) |prong| {
        try self.parseProng(prong, false);
        assert(!prong.isOverlapping(merged));
        const new_merge = try merged.mergeUnsafe(prong, allocator);
        merged.deinit();
        merged = new_merge;
    }

    try merged.invert();
    merged.consuming = false;
    merged.dest = fail;
    try self.parseProng(merged, true);

    try self.writer.print("}}\n", .{});
}

fn parseProng(self: *CodeGen, prong: lir.MatchProng, fail_prong: bool) !void {
    if (prong.labels.items.len == 0) return;
    for (prong.labels.items) |range| {
        try self.parseRange(range);
        try self.writer.print(",\n", .{});
    }

    try self.writer.print("=> {{\nself.state = {d};\n", .{prong.dest.id});

    // prong.consuming => !fail_prong
    assert(!prong.consuming or !fail_prong);
    if (prong.consuming) {
        try self.writer.print("self.acc += 1;\n", .{});
    } else if (fail_prong) {
        try self.writer.print("self.acc = 0;\n", .{});
        try self.writer.print(
            "self.infer_actions.shrinkRetainingCapacity(self.stack_start);\n",
            .{},
        );
        try self.writer.print("continue;\n", .{});
    }

    try self.writer.print("}},\n", .{});
}

fn parseRange(self: *CodeGen, range: lir.Range) !void {
    try su.writeChar(self.writer, range.from);
    if (range.isChar()) return;

    try self.writer.print("...", .{});
    try su.writeChar(self.writer, range.to);
}

fn parseString(self: *CodeGen, instr: *lir.Instr, fail: *lir.Block) !void {
    const w = self.writer;
    const lit = instr.data.str;
    try w.print("if (self.chars.len >= self.start + {d} + self.acc and\n", .{lit.len});
    try w.print("{s}std.mem.eql(u8, ", .{if (instr.meta.neg) "!" else ""});
    try su.writeString(self.writer, lit);
    try w.print(
        ", self\n.chars[self.start + self.acc..self.start + self.acc + {d}])){{\n",
        .{lit.len},
    );
    if (!instr.meta.neg and !instr.meta.pos) {
        try w.print("self.acc += {d};\n", .{lit.len});
    }
    try w.print("}} else {{\n", .{});
    try w.print("self.state = {d};\nself.acc = 0;\n", .{fail.id});
    try w.print("self.infer_actions.shrinkRetainingCapacity(self.stack_start);\n", .{});
    try w.print("continue;\n", .{});
    try w.print("}}\n", .{});
}

fn callAction(self: *CodeGen) !void {
    const start =
        \\fn callAction(self: *@This(), state: usize, start: usize, length: usize) !void {
        \\    _ = start + length + self.state; // just to be able to compile 
        \\
        \\    switch (state) {
    ;
    const end =
        \\        else => unreachable,
        \\    }
        \\}
    ;
    try self.writer.print("{s}\n", .{start});

    for (self.ir.actions.items) |act| try self.blockActionExec(act);

    try self.writer.print("{s}\n", .{end});
}

fn blockActionExec(self: *CodeGen, action: lir.Action) !void {
    try self.writer.print("{d} => {{\n", .{action.base.id});

    if (!action.isEmpty()) try self.actionExec(action);

    try self.writer.print("}},\n", .{});
}

fn actionReturnExec(self: *CodeGen, rets: []const lir.LabeledRet) !void {
    for (0..rets.len) |i| {
        const ret = rets[rets.len - 1 - i];
        if (ret.ret.isNone()) continue;
        try self.writer.print(
            "const @\"${d}\" = self.calc_stack.pop().?.type_{d};\n",
            .{ ret.lbl, ret.place.base },
        );

        if (ret.needs_mut) {
            try self.writer.print(
                "var @\"$*{d}\" = @\"${d}\";\n",
                .{ ret.lbl, ret.lbl },
            );
        }
    }
}

fn actionBaseExec(self: *CodeGen, base: pir.ActionBase) !void {
    const ret = base.id == 0;
    const returns = !base.return_type.isNone();

    if (ret and returns) {
        try self.writer
            .print("const @\"$ret\": {s} = ", .{base.return_type});
    } else if (returns) {
        try self.writer
            .print("const @\"${d}\": {s} = ", .{ base.id - 1, base.return_type });
    }

    // write the action
    var i: usize = 0;
    while (base.getNext(i)) |action_var| {
        const end =
            @intFromPtr(action_var.var_decl.ptr) -
            @intFromPtr(base.data.ptr);

        try self.writer.print("{s}", .{base.data[i..end]});

        if (action_var.isEscape()) {
            try self.writer.print("{s}", .{action_var.var_decl[1..]});
        } else if (action_var.arg_num) |num| {
            try self.writer.print(
                "@\"${s}{d}\"",
                .{ if (action_var.escape) "*" else "", num },
            );
        } else {
            assert(action_var.isMatchedString());
            try self.writer.print(
                "self.chars[start .. start + length]",
                .{},
            );
        }

        i = end + action_var.var_decl.len;
    }
    try self.writer.print("{s}", .{base.data[i..]});

    if (!returns) return;
    try self.writer.print(";\n", .{});

    if (!base.mut) return;
    try self.writer.print(
        "var \"$*{d}\" = @\"${d}\"",
        .{ base.id - 1, base.id - 1 },
    );
}

fn actionExec(self: *CodeGen, action: lir.Action) !void {
    const rets = action.args.items;
    try self.actionReturnExec(rets);

    // check that the action is an expression or not
    const bases = action.bases.items;
    for (0..bases.len) |i| {
        const base = bases[bases.len - 1 - i];
        try self.actionBaseExec(base);
    }

    // add the return value to the calc stack
    const last_base = bases[0];
    const returns = !last_base.return_type.isNone();
    if (!returns) return;
    try self.writer.print(
        "try self.calc_stack.append(.{{.type_{d} = @\"$ret\"}});\n",
        .{action.base.base},
    );
}

fn infer(self: *CodeGen) !void {
    try self.writer.print(skl.infer, .{
        if (self.parse_return.isNone())
            "void{}"
        else
            "self.calc_stack.pop().?.type_0",
    });
}

fn memoInfer(self: *CodeGen) !void {
    const inferStart =
        \\fn memoInfer(self: *@This(), state: State, start: CharIdx) Allocator.Error!void {
        \\self.infer_start = start;
        \\self.infer_acc = start;
        \\self.infer_state = ActionTranslate[state];
        \\self.infer_done = false;
        \\
        \\while (!self.infer_done) {
        \\    switch (self.infer_state) {
    ;
    const inferEnd =
        \\        else => unreachable,
        \\    }
        \\}
        \\}
    ;
    try self.writer.print("{s}\n", .{inferStart});

    var count: usize = 0;
    for (self.ir.actions.items) |action| {
        try self.inferAction(action, &count);
    }

    try self.writer.print("{s}\n", .{inferEnd});
}

fn inferAction(self: *CodeGen, action: lir.Action, count: *usize) !void {
    for (action.nonterms.items) |nonterm| {
        const add = nonterm.calls.id;
        try self.inferCall(count, nonterm.consumes, add, false);
    }

    try self.inferCall(count, action.last_offset, action.base.id, true);
}

fn inferCall(
    self: *CodeGen,
    count: *usize,
    offset: usize,
    add: usize,
    comptime ret: bool,
) !void {
    try self.writer.print("{d} => {{\n", .{count.*});
    try self.writer.print("self.infer_acc += {d};\n", .{offset});
    try self.writer.print(if (ret)
        "try self.returnFromInfer({d});\n"
    else
        "try self.inferNonterminal({d});\n", .{add});
    try self.writer.print("}},\n", .{});
    count.* += 1;
}
